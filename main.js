/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  AddBookModal: () => AddBookModal,
  EnglishVocabularyPlugin: () => EnglishVocabularyPlugin,
  default: () => EnglishVocabularyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/features/settings/ui/settings.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
function isPlainTextApiKey(apiKey) {
  if (!apiKey)
    return false;
  const apiKeyPatterns = [
    /^sk-[a-zA-Z0-9]{32,}$/,
    // OpenAI API 키
    /^sk-ant-[a-zA-Z0-9-_]{95}$/,
    // Anthropic API 키
    /^AIza[a-zA-Z0-9-_]{35}$/,
    // Google API 키
    /^[a-zA-Z0-9-_]{20,}$/
    // 일반적인 긴 토큰
  ];
  return apiKeyPatterns.some((pattern) => pattern.test(apiKey));
}
function encryptApiKey(apiKey) {
  if (!apiKey)
    return "";
  if (!isPlainTextApiKey(apiKey)) {
    return apiKey;
  }
  try {
    const key = "obsidian-vocab-temp-key-2024";
    let encrypted = "";
    for (let i = 0; i < apiKey.length; i++) {
      const charCode = apiKey.charCodeAt(i) ^ key.charCodeAt(i % key.length);
      encrypted += String.fromCharCode(charCode);
    }
    return btoa(encrypted);
  } catch (error) {
    console.error("\uB3D9\uAE30 \uC554\uD638\uD654 \uC2E4\uD328:", error);
    return "";
  }
}
function decryptApiKey(encryptedApiKey) {
  if (!encryptedApiKey)
    return "";
  if (isPlainTextApiKey(encryptedApiKey)) {
    return encryptedApiKey;
  }
  try {
    const key = "obsidian-vocab-temp-key-2024";
    const decoded = atob(encryptedApiKey);
    let decrypted = "";
    for (let i = 0; i < decoded.length; i++) {
      const charCode = decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length);
      decrypted += String.fromCharCode(charCode);
    }
    return decrypted;
  } catch (error) {
    console.warn("\uBCF5\uD638\uD654 \uC2E4\uD328, \uD3C9\uBB38\uC73C\uB85C \uAC04\uC8FC:", error.message);
    return encryptedApiKey;
  }
}
function maskApiKey(apiKey) {
  if (!apiKey || typeof apiKey !== "string")
    return "";
  if (apiKey.length <= 8)
    return "*".repeat(apiKey.length);
  return apiKey.substring(0, 4) + "*".repeat(apiKey.length - 8) + apiKey.substring(apiKey.length - 4);
}
function formatDate(dateString) {
  if (!dateString) {
    return "\uC5C6\uC74C";
  }
  const date = new Date(dateString);
  if (isNaN(date.getTime())) {
    return "\uC798\uBABB\uB41C \uB0A0\uC9DC";
  }
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric"
  });
}

// src/shared/Config.ts
var DEFAULT_CONFIG = {
  api: {
    timeouts: {
      default: 3e4,
      // 30초
      llm: 6e4,
      // 60초
      tts: 15e3
      // 15초
    },
    retries: {
      maxAttempts: 3,
      delayMs: 1e3,
      exponentialBackoff: true
    },
    rateLimiting: {
      requestsPerMinute: 60,
      burstLimit: 10
    }
  },
  batch: {
    defaultSize: 5,
    maxSize: 20,
    delayBetweenBatches: 200,
    maxConcurrentBatches: 3
  },
  audio: {
    maxPoolSize: 10,
    autoCleanupTimeoutMs: 3e4,
    // 30초
    maxDurationMs: 3e5
    // 5분
  },
  database: {
    autoSaveInterval: 5e3,
    // 5초
    backupEnabled: true,
    maxFileSize: 10485760,
    // 10MB
    compressionEnabled: false
  },
  learning: {
    spaced_repetition: {
      initialInterval: 1,
      // 1일
      easyBonus: 1.3,
      hardPenalty: 0.8,
      maxInterval: 365,
      // 1년
      minInterval: 1
      // 1일
    },
    load_balancing: {
      maxDailyReviews: 100,
      fuzzingPercentage: 5,
      distributionWindow: 7
      // 7일
    }
  },
  ui: {
    animationDuration: 300,
    // 300ms
    progressUpdateInterval: 100,
    // 100ms
    notificationTimeout: 5e3,
    // 5초
    modalCloseDelay: 500
    // 500ms
  },
  security: {
    apiKeyEncryption: {
      iterations: 1e4,
      keyLength: 32,
      saltLength: 16
    },
    sessionTimeout: 36e5,
    // 1시간
    maxLoginAttempts: 5
  }
};
var DEVELOPMENT_CONFIG = {
  api: {
    timeouts: {
      default: 1e4,
      llm: 2e4,
      tts: 5e3
    },
    retries: {
      maxAttempts: 1,
      delayMs: 500,
      exponentialBackoff: false
    }
  },
  batch: {
    defaultSize: 2,
    maxSize: 5,
    delayBetweenBatches: 100
  },
  database: {
    autoSaveInterval: 1e3,
    backupEnabled: false
  }
};
var PRODUCTION_CONFIG = {
  api: {
    retries: {
      maxAttempts: 5,
      delayMs: 2e3,
      exponentialBackoff: true
    }
  },
  batch: {
    defaultSize: 10,
    maxSize: 50,
    delayBetweenBatches: 500
  },
  database: {
    autoSaveInterval: 1e4,
    backupEnabled: true,
    compressionEnabled: true
  }
};
var ConfigManager = class _ConfigManager {
  constructor() {
    this.config = this.mergeConfigs(DEFAULT_CONFIG, this.getEnvironmentConfig());
  }
  static getInstance() {
    if (!_ConfigManager.instance) {
      _ConfigManager.instance = new _ConfigManager();
    }
    return _ConfigManager.instance;
  }
  getConfig() {
    return { ...this.config };
  }
  getValue(path) {
    return this.getNestedValue(this.config, path);
  }
  updateConfig(updates) {
    this.config = this.mergeConfigs(this.config, updates);
  }
  getEnvironmentConfig() {
    const isDevelopment = true;
    return isDevelopment ? DEVELOPMENT_CONFIG : PRODUCTION_CONFIG;
  }
  mergeConfigs(base, override) {
    return this.deepMerge(base, override);
  }
  deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        const sourceValue = source[key];
        const targetValue = result[key];
        if (this.isObject(sourceValue) && this.isObject(targetValue)) {
          result[key] = this.deepMerge(targetValue, sourceValue);
        } else if (sourceValue !== void 0) {
          result[key] = sourceValue;
        }
      }
    }
    return result;
  }
  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  getNestedValue(obj, path) {
    return path.split(".").reduce((current, key) => current == null ? void 0 : current[key], obj);
  }
};
function getConfigValue(path) {
  return ConfigManager.getInstance().getValue(path);
}
var CONFIG_PATHS = {
  API_TIMEOUT_DEFAULT: "api.timeouts.default",
  API_TIMEOUT_LLM: "api.timeouts.llm",
  API_TIMEOUT_TTS: "api.timeouts.tts",
  API_RETRY_MAX_ATTEMPTS: "api.retries.maxAttempts",
  API_RETRY_DELAY: "api.retries.delayMs",
  BATCH_DEFAULT_SIZE: "batch.defaultSize",
  BATCH_MAX_SIZE: "batch.maxSize",
  BATCH_DELAY: "batch.delayBetweenBatches",
  AUDIO_MAX_POOL_SIZE: "audio.maxPoolSize",
  AUDIO_CLEANUP_TIMEOUT: "audio.autoCleanupTimeoutMs",
  LEARNING_INITIAL_INTERVAL: "learning.spaced_repetition.initialInterval",
  LEARNING_EASY_BONUS: "learning.spaced_repetition.easyBonus",
  LEARNING_HARD_PENALTY: "learning.spaced_repetition.hardPenalty",
  UI_ANIMATION_DURATION: "ui.animationDuration",
  UI_NOTIFICATION_TIMEOUT: "ui.notificationTimeout"
};

// src/shared/RetryPolicy.ts
var RetryPolicy = class {
  constructor(options = {}) {
    var _a, _b, _c, _d, _e, _f;
    this.options = {
      maxAttempts: (_a = options.maxAttempts) != null ? _a : getConfigValue(CONFIG_PATHS.API_RETRY_MAX_ATTEMPTS),
      delayMs: (_b = options.delayMs) != null ? _b : getConfigValue(CONFIG_PATHS.API_RETRY_DELAY),
      exponentialBackoff: (_c = options.exponentialBackoff) != null ? _c : true,
      maxDelayMs: (_d = options.maxDelayMs) != null ? _d : 3e4,
      // 30초
      backoffMultiplier: (_e = options.backoffMultiplier) != null ? _e : 2,
      retryCondition: (_f = options.retryCondition) != null ? _f : this.defaultRetryCondition
    };
  }
  // 기본 재시도 조건
  defaultRetryCondition(error) {
    const retryableErrors = [
      "NetworkError",
      "TimeoutError",
      "fetch",
      "502",
      "503",
      "504",
      // 서버 에러
      "ECONNRESET",
      "ETIMEDOUT",
      "ENOTFOUND"
    ];
    const errorMessage = error.message.toLowerCase();
    const errorName = error.name.toLowerCase();
    return retryableErrors.some(
      (pattern) => errorMessage.includes(pattern.toLowerCase()) || errorName.includes(pattern.toLowerCase())
    );
  }
  // 지수 백오프 계산
  calculateDelay(attempt) {
    if (!this.options.exponentialBackoff) {
      return this.options.delayMs;
    }
    const delay2 = this.options.delayMs * Math.pow(this.options.backoffMultiplier, attempt - 1);
    const jitter = delay2 * 0.2 * (Math.random() - 0.5);
    const finalDelay = Math.floor(delay2 + jitter);
    return Math.min(finalDelay, this.options.maxDelayMs);
  }
  // 비동기 함수 재시도
  async execute(fn) {
    const startTime = Date.now();
    let lastError;
    for (let attempt = 1; attempt <= this.options.maxAttempts; attempt++) {
      try {
        const result = await fn();
        return {
          success: true,
          result,
          attempts: attempt,
          totalDuration: Date.now() - startTime
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt === this.options.maxAttempts || !this.options.retryCondition(lastError)) {
          break;
        }
        const delay2 = this.calculateDelay(attempt);
        await this.delay(delay2);
      }
    }
    return {
      success: false,
      error: lastError,
      attempts: this.options.maxAttempts,
      totalDuration: Date.now() - startTime
    };
  }
  // 동기 함수 재시도
  executeSync(fn) {
    const startTime = Date.now();
    let lastError;
    for (let attempt = 1; attempt <= this.options.maxAttempts; attempt++) {
      try {
        const result = fn();
        return {
          success: true,
          result,
          attempts: attempt,
          totalDuration: Date.now() - startTime
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt === this.options.maxAttempts || !this.options.retryCondition(lastError)) {
          break;
        }
      }
    }
    return {
      success: false,
      error: lastError,
      attempts: this.options.maxAttempts,
      totalDuration: Date.now() - startTime
    };
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  // 설정 업데이트
  updateOptions(options) {
    this.options = { ...this.options, ...options };
  }
  // 현재 설정 반환
  getOptions() {
    return { ...this.options };
  }
};
var APIRetryPolicy = class extends RetryPolicy {
  constructor(options = {}) {
    super({
      maxAttempts: 3,
      delayMs: 2e3,
      exponentialBackoff: true,
      maxDelayMs: 15e3,
      retryCondition: (error) => {
        const retryableErrors = [
          "429",
          // Rate limit
          "502",
          "503",
          "504",
          // Server errors
          "timeout",
          "network"
        ];
        const errorText = error.message.toLowerCase();
        return retryableErrors.some((pattern) => errorText.includes(pattern));
      },
      ...options
    });
  }
};
async function retryAPICall(fn, options) {
  const policy = new APIRetryPolicy(options);
  const result = await policy.execute(fn);
  if (result.success) {
    return result.result;
  } else {
    throw result.error;
  }
}

// src/infrastructure/llm/LLMService.ts
var import_obsidian = require("obsidian");
var LLMService = class {
  constructor(settings) {
    this.settings = settings;
    this.retryPolicy = new APIRetryPolicy({
      maxAttempts: 3,
      delayMs: 2e3,
      exponentialBackoff: true
    });
  }
  // 현재 선택된 제공업체의 API 키를 가져오는 메서드
  getCurrentApiKey() {
    const provider = this.settings.llmProvider;
    let encryptedKey = "";
    switch (provider) {
      case "openai":
        encryptedKey = this.settings.openaiApiKey;
        break;
      case "anthropic":
        encryptedKey = this.settings.anthropicApiKey;
        break;
      case "google":
        encryptedKey = this.settings.googleApiKey;
        break;
    }
    return decryptApiKey(encryptedKey);
  }
  async testConnection() {
    try {
      const apiKey = this.getCurrentApiKey();
      if (!apiKey) {
        return { success: false, error: "API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4." };
      }
      const testPrompt = 'Hello, this is a test message. Please respond with "OK" if you can read this.';
      const response = await this.callLLM(testPrompt);
      if (response.success) {
        return { success: true, data: "API \uC5F0\uACB0 \uC131\uACF5" };
      } else {
        return { success: false, error: response.error || "API \uC5F0\uACB0 \uC2E4\uD328" };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  async getWordDetails(word) {
    try {
      const apiKey = this.getCurrentApiKey();
      if (!apiKey) {
        return { success: false, error: "API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4." };
      }
      const prompt = this.createWordDetailPrompt(word);
      const response = await this.callLLM(prompt);
      if (response.success) {
        const parsedData = this.parseWordDetailResponse(response.data, word);
        return { success: true, data: parsedData };
      } else {
        return { success: false, error: response.error || "\uB2E8\uC5B4 \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294\uB370 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4." };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  async getMultipleWordDetails(words, progressCallback) {
    try {
      const apiKey = this.getCurrentApiKey();
      if (!apiKey) {
        return { success: false, error: "API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4." };
      }
      if (words.length === 0) {
        return { success: false, error: "\uCC98\uB9AC\uD560 \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4." };
      }
      const BATCH_SIZE = 20;
      const allResults = [];
      const totalBatches = Math.ceil(words.length / BATCH_SIZE);
      if (progressCallback) {
        progressCallback(0, words.length, `\uCD1D ${words.length}\uAC1C \uB2E8\uC5B4\uB97C ${totalBatches}\uAC1C \uBC30\uCE58\uB85C \uB098\uB204\uC5B4 \uCC98\uB9AC\uD569\uB2C8\uB2E4.`);
      }
      for (let i = 0; i < words.length; i += BATCH_SIZE) {
        const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
        const batchWords = words.slice(i, i + BATCH_SIZE);
        if (progressCallback) {
          progressCallback(i, words.length, `\uBC30\uCE58 ${batchNumber}/${totalBatches} \uCC98\uB9AC \uC911... (${batchWords.length}\uAC1C \uB2E8\uC5B4)`);
        }
        try {
          const prompt = this.createMultipleWordDetailPrompt(batchWords);
          const response = await this.callLLM(prompt);
          if (response.success) {
            const parsedData = this.parseMultipleWordDetailResponse(response.data, batchWords);
            allResults.push(...parsedData);
            if (progressCallback) {
              progressCallback(i + batchWords.length, words.length, `\uBC30\uCE58 ${batchNumber} \uC644\uB8CC: ${parsedData.length}\uAC1C \uB2E8\uC5B4 \uCC98\uB9AC\uB428`);
            }
          } else {
            console.error(`\uBC30\uCE58 ${batchNumber} \uC2E4\uD328:`, response.error);
            if (progressCallback) {
              progressCallback(i, words.length, `\uBC30\uCE58 ${batchNumber} \uC2E4\uD328, \uAC1C\uBCC4 \uCC98\uB9AC\uB85C \uC804\uD658...`);
            }
            const individualResults = await this.processWordsIndividually(batchWords, progressCallback, i);
            allResults.push(...individualResults);
          }
        } catch (error) {
          console.error(`\uBC30\uCE58 ${batchNumber} \uCC98\uB9AC \uC911 \uC624\uB958:`, error);
          if (progressCallback) {
            progressCallback(i, words.length, `\uBC30\uCE58 ${batchNumber} \uC624\uB958, \uAC1C\uBCC4 \uCC98\uB9AC\uB85C \uC804\uD658...`);
          }
          const individualResults = await this.processWordsIndividually(batchWords, progressCallback, i);
          allResults.push(...individualResults);
        }
        if (i + BATCH_SIZE < words.length) {
          await this.delay(1e3);
        }
      }
      if (progressCallback) {
        progressCallback(words.length, words.length, `\uBAA8\uB4E0 \uBC30\uCE58 \uCC98\uB9AC \uC644\uB8CC. \uCD1D ${allResults.length}\uAC1C \uB2E8\uC5B4 \uB370\uC774\uD130 \uC218\uC9D1\uB428`);
      }
      return { success: true, data: allResults };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  // 개별 단어 처리 (배치 실패 시 폴백)
  async processWordsIndividually(words, progressCallback, startIndex = 0) {
    const results = [];
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const currentIndex = startIndex + i;
      try {
        if (progressCallback) {
          progressCallback(currentIndex, startIndex + words.length, `\uAC1C\uBCC4 \uCC98\uB9AC: "${word}"`);
        }
        const response = await this.getWordDetails(word);
        if (response.success && response.data) {
          results.push(response.data);
        } else {
          console.warn(`\uB2E8\uC5B4 "${word}" \uCC98\uB9AC \uC2E4\uD328:`, response.error);
          results.push({
            word: word.toLowerCase(),
            pronunciation: "",
            meanings: ["\uCC98\uB9AC \uC2E4\uD328"],
            examples: [],
            similarWords: []
          });
        }
        await this.delay(500);
      } catch (error) {
        console.error(`\uB2E8\uC5B4 "${word}" \uAC1C\uBCC4 \uCC98\uB9AC \uC911 \uC624\uB958:`, error);
        results.push({
          word: word.toLowerCase(),
          pronunciation: "",
          meanings: ["\uCC98\uB9AC \uC624\uB958"],
          examples: [],
          similarWords: []
        });
      }
    }
    return results;
  }
  // 지연 함수
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  createWordDetailPrompt(word) {
    return `\uB2E4\uC74C \uC601\uC5B4 \uB2E8\uC5B4 "${word}"\uC5D0 \uB300\uD55C \uC0C1\uC138 \uC815\uBCF4\uB97C JSON \uD615\uC2DD\uC73C\uB85C \uC81C\uACF5\uD574\uC8FC\uC138\uC694.

\uC694\uAD6C\uC0AC\uD56D:
1. \uBC1C\uC74C\uAE30\uD638 (IPA \uD615\uC2DD)
2. \uD55C\uAE00 \uB73B\uB4E4 (\uC5EC\uB7EC \uAC1C\uC77C \uC218 \uC788\uC74C)
3. \uAC01 \uB73B\uBCC4\uB85C \uC601\uC5B4 \uC608\uBB38\uACFC \uD55C\uAE00 \uBC88\uC5ED (\uAC01 \uB73B\uB2F9 2-3\uAC1C\uC758 \uC608\uBB38 \uC81C\uACF5)
4. \uC720\uC0AC\uD55C \uC601\uC5B4 \uB2E8\uC5B4\uB4E4

\uC751\uB2F5 \uD615\uC2DD:
{
  "word": "${word}",
  "pronunciation": "/\uBC1C\uC74C\uAE30\uD638/",
  "meanings": ["\uB73B1", "\uB73B2", "\uB73B3"],
  "examples": [
    {
      "english": "\uC601\uC5B4 \uC608\uBB38 1",
      "korean": "\uD55C\uAE00 \uBC88\uC5ED 1"
    },
    {
      "english": "\uC601\uC5B4 \uC608\uBB38 2", 
      "korean": "\uD55C\uAE00 \uBC88\uC5ED 2"
    },
    {
      "english": "\uC601\uC5B4 \uC608\uBB38 3",
      "korean": "\uD55C\uAE00 \uBC88\uC5ED 3"
    }
  ],
  "similarWords": ["\uC720\uC0AC\uB2E8\uC5B41", "\uC720\uC0AC\uB2E8\uC5B42", "\uC720\uC0AC\uB2E8\uC5B43"]
}

JSON \uD615\uC2DD\uC73C\uB85C\uB9CC \uC751\uB2F5\uD574\uC8FC\uC138\uC694. \uB2E4\uB978 \uC124\uBA85\uC740 \uD3EC\uD568\uD558\uC9C0 \uB9C8\uC138\uC694.`;
  }
  createMultipleWordDetailPrompt(words) {
    const wordList = words.join(", ");
    return `\uB2E4\uC74C \uC601\uC5B4 \uB2E8\uC5B4\uB4E4\uC5D0 \uB300\uD55C \uC0C1\uC138 \uC815\uBCF4\uB97C \uC815\uD655\uD55C JSON \uD615\uC2DD\uC73C\uB85C \uC81C\uACF5\uD574\uC8FC\uC138\uC694: ${wordList}

\uC694\uAD6C\uC0AC\uD56D:
- \uAC01 \uB2E8\uC5B4\uC5D0 \uB300\uD574 \uBC1C\uC74C\uAE30\uD638 (IPA \uD615\uC2DD), \uD55C\uAE00 \uB73B\uB4E4, \uC601\uC5B4 \uC608\uBB38\uACFC \uD55C\uAE00 \uBC88\uC5ED, \uC720\uC0AC\uD55C \uC601\uC5B4 \uB2E8\uC5B4\uB4E4\uC744 \uD3EC\uD568
- \uAC01 \uB73B\uBCC4\uB85C 2-3\uAC1C\uC758 \uC608\uBB38\uC744 \uC81C\uACF5\uD574\uC8FC\uC138\uC694
- JSON \uD615\uC2DD\uB9CC \uC751\uB2F5\uD558\uACE0 \uB2E4\uB978 \uC124\uBA85\uC740 \uD3EC\uD568\uD558\uC9C0 \uB9C8\uC138\uC694
- \uBAA8\uB4E0 \uBB38\uC790\uC5F4\uC740 \uC774\uC911 \uB530\uC634\uD45C\uB85C \uAC10\uC2F8\uC8FC\uC138\uC694
- \uBC30\uC5F4\uACFC \uAC1D\uCCB4\uB294 \uC815\uD655\uD55C JSON \uBB38\uBC95\uC744 \uB530\uB974\uC138\uC694

\uC751\uB2F5 \uD615\uC2DD:
[
  {
    "word": "\uB2E8\uC5B41",
    "pronunciation": "/\uBC1C\uC74C\uAE30\uD638/",
    "meanings": ["\uB73B1", "\uB73B2"],
    "examples": [
      {
        "english": "\uC601\uC5B4 \uC608\uBB38 1",
        "korean": "\uD55C\uAE00 \uBC88\uC5ED 1"
      },
      {
        "english": "\uC601\uC5B4 \uC608\uBB38 2",
        "korean": "\uD55C\uAE00 \uBC88\uC5ED 2"
      },
      {
        "english": "\uC601\uC5B4 \uC608\uBB38 3",
        "korean": "\uD55C\uAE00 \uBC88\uC5ED 3"
      }
    ],
    "similarWords": ["\uC720\uC0AC\uB2E8\uC5B41", "\uC720\uC0AC\uB2E8\uC5B42"]
  }
]

\uC911\uC694: JSON \uD615\uC2DD\uB9CC \uC751\uB2F5\uD558\uACE0 \uB2E4\uB978 \uD14D\uC2A4\uD2B8\uB294 \uD3EC\uD568\uD558\uC9C0 \uB9C8\uC138\uC694.`;
  }
  async callLLM(prompt) {
    try {
      const provider = this.settings.llmProvider;
      switch (provider) {
        case "openai":
          return await this.callOpenAI(prompt);
        case "anthropic":
          return await this.callAnthropic(prompt);
        case "google":
          return await this.callGoogle(prompt);
        default:
          return { success: false, error: "\uC9C0\uC6D0\uD558\uC9C0 \uC54A\uB294 LLM \uC81C\uACF5\uC5C5\uCCB4\uC785\uB2C8\uB2E4." };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  async callOpenAI(prompt) {
    var _a, _b, _c;
    try {
      const response = await retryAPICall(async () => {
        return (0, import_obsidian.requestUrl)({
          url: "https://api.openai.com/v1/chat/completions",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.getCurrentApiKey()}`
          },
          body: JSON.stringify({
            model: this.settings.llmModel,
            messages: [
              {
                role: "user",
                content: prompt
              }
            ],
            temperature: 0.3,
            max_tokens: 4e3
          })
        });
      });
      if (response.status >= 400) {
        const errorData = JSON.parse(response.text);
        return { success: false, error: ((_a = errorData.error) == null ? void 0 : _a.message) || "OpenAI API \uD638\uCD9C \uC2E4\uD328" };
      }
      const data = JSON.parse(response.text);
      const content = (_c = (_b = data.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content;
      if (!content) {
        return { success: false, error: "\uC751\uB2F5 \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4." };
      }
      return { success: true, data: content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  async callAnthropic(prompt) {
    var _a, _b, _c;
    if (typeof window === "undefined" || typeof window !== "undefined" && "process" in window && ((_a = window.process) == null ? void 0 : _a.type) === "renderer") {
      try {
        const response = await (0, import_obsidian.requestUrl)({
          url: "https://api.anthropic.com/v1/messages",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-api-key": this.getCurrentApiKey(),
            "anthropic-version": "2023-06-01"
          },
          body: JSON.stringify({
            model: this.settings.llmModel,
            max_tokens: 3e4,
            messages: [
              {
                role: "user",
                content: prompt
              }
            ]
          })
        });
        if (response.status >= 400) {
          const errorData = JSON.parse(response.text);
          return { success: false, error: ((_b = errorData.error) == null ? void 0 : _b.message) || "Anthropic API \uD638\uCD9C \uC2E4\uD328" };
        }
        const data = JSON.parse(response.text);
        const content = (_c = data.content[0]) == null ? void 0 : _c.text;
        if (!content) {
          return { success: false, error: "\uC751\uB2F5 \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4." };
        }
        return { success: true, data: content };
      } catch (error) {
        return { success: false, error: error.message };
      }
    } else {
      return {
        success: false,
        error: "Anthropic API\uB294 \uBE0C\uB77C\uC6B0\uC800 \uD658\uACBD\uC5D0\uC11C \uC9C1\uC811 \uD638\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uB370\uC2A4\uD06C\uD1B1 \uC571(Obsidian)\uC5D0\uC11C\uB9CC \uB3D9\uC791\uD569\uB2C8\uB2E4."
      };
    }
  }
  async callGoogle(prompt) {
    var _a, _b, _c, _d;
    try {
      const response = await retryAPICall(async () => {
        return (0, import_obsidian.requestUrl)({
          url: `https://generativelanguage.googleapis.com/v1beta/models/${this.settings.llmModel}:generateContent?key=${this.getCurrentApiKey()}`,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            contents: [
              {
                parts: [
                  {
                    text: prompt
                  }
                ]
              }
            ],
            generationConfig: {
              temperature: 0.3,
              maxOutputTokens: 4e3
            }
          })
        });
      });
      if (response.status >= 400) {
        const errorData = JSON.parse(response.text);
        return { success: false, error: ((_a = errorData.error) == null ? void 0 : _a.message) || "Google API \uD638\uCD9C \uC2E4\uD328" };
      }
      const data = JSON.parse(response.text);
      const content = (_d = (_c = (_b = data.candidates[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts[0]) == null ? void 0 : _d.text;
      if (!content) {
        return { success: false, error: "\uC751\uB2F5 \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4." };
      }
      return { success: true, data: content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  parseWordDetailResponse(response, originalWord) {
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("JSON \uD615\uC2DD\uC758 \uC751\uB2F5\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
      const jsonData = JSON.parse(jsonMatch[0]);
      const validatedExamples = this.validateExamples(jsonData.examples);
      return {
        word: jsonData.word || originalWord,
        pronunciation: jsonData.pronunciation || "",
        meanings: jsonData.meanings || [],
        examples: validatedExamples,
        similarWords: jsonData.similarWords || []
      };
    } catch (error) {
      return {
        word: originalWord,
        pronunciation: "",
        meanings: ["\uC758\uBBF8\uB97C \uD30C\uC2F1\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."],
        examples: [],
        similarWords: []
      };
    }
  }
  // 예문 데이터 검증 및 정리
  validateExamples(examples) {
    if (!Array.isArray(examples)) {
      return [];
    }
    const validatedExamples = [];
    for (const example of examples) {
      if (example && typeof example === "object") {
        const english = example.english || example.english_text || example.text || "";
        const korean = example.korean || example.korean_text || example.translation || "";
        if (english.trim() && korean.trim()) {
          validatedExamples.push({
            english: english.trim(),
            korean: korean.trim()
          });
        }
      }
    }
    return validatedExamples;
  }
  parseMultipleWordDetailResponse(response, originalWords) {
    try {
      let jsonMatch = response.match(/\[[\s\S]*\]/);
      if (!jsonMatch) {
        const objectMatches = response.match(/\{[^{}]*"word"[^{}]*\}/g);
        if (objectMatches && objectMatches.length > 0) {
          const jsonString = "[" + objectMatches.join(",") + "]";
          try {
            const jsonData2 = JSON.parse(jsonString);
            if (Array.isArray(jsonData2)) {
              return this.processJsonData(jsonData2, originalWords);
            }
          } catch (e) {
          }
        }
        const lastCompleteMatch = response.match(/\[[\s\S]*\}(?=\s*$)/);
        if (lastCompleteMatch) {
          jsonMatch = [lastCompleteMatch[0] + "]"];
        } else {
          throw new Error("JSON \uBC30\uC5F4\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        }
      }
      let jsonData;
      let parsedLength = 0;
      try {
        jsonData = JSON.parse(jsonMatch[0]);
      } catch (parseError) {
        const results = this.parseIncrementalJson(response);
        if (results.length > 0) {
          return results;
        }
        const fixedJson = this.fixJsonString(jsonMatch[0]);
        try {
          jsonData = JSON.parse(fixedJson);
        } catch (secondError) {
          throw new Error("JSON \uD30C\uC2F1 \uBC0F \uBCF5\uAD6C \uC2E4\uD328");
        }
      }
      if (!Array.isArray(jsonData)) {
        throw new Error("\uC751\uB2F5\uC774 \uBC30\uC5F4 \uD615\uC2DD\uC774 \uC544\uB2D9\uB2C8\uB2E4.");
      }
      return this.processJsonData(jsonData, originalWords);
    } catch (error) {
      console.error("\uC5EC\uB7EC \uB2E8\uC5B4 \uC751\uB2F5 \uD30C\uC2F1 \uC624\uB958:", error);
      console.error("\uC6D0\uBCF8 \uC751\uB2F5:", response);
      return originalWords.map((word) => ({
        word: word.toLowerCase(),
        pronunciation: "",
        meanings: [],
        examples: [],
        similarWords: []
      }));
    }
  }
  // 점진적 JSON 파싱 - 완전한 객체들만 파싱
  parseIncrementalJson(response) {
    const results = [];
    const objectRegex = /\{[^{}]*"word"[^{}]*"pronunciation"[^{}]*"meanings"[^{}]*"examples"[^{}]*"similarWords"[^{}]*\}/g;
    let match;
    while ((match = objectRegex.exec(response)) !== null) {
      try {
        const objectData = JSON.parse(match[0]);
        if (objectData && objectData.word) {
          const validatedExamples = this.validateExamples(objectData.examples);
          const wordData = {
            word: objectData.word.toLowerCase(),
            pronunciation: objectData.pronunciation || "",
            meanings: Array.isArray(objectData.meanings) ? objectData.meanings : [],
            examples: validatedExamples,
            similarWords: Array.isArray(objectData.similarWords) ? objectData.similarWords : []
          };
          results.push(wordData);
        }
      } catch (e) {
        continue;
      }
    }
    return results;
  }
  // WordDetailData를 WordData로 변환하는 메서드
  convertToWordData(wordDetail) {
    return {
      word: wordDetail.word,
      pronunciation: wordDetail.pronunciation,
      meanings: wordDetail.meanings,
      similarWords: wordDetail.similarWords,
      examples: wordDetail.examples
    };
  }
  // JSON 데이터 처리
  processJsonData(jsonData, originalWords) {
    const results = [];
    for (const item of jsonData) {
      if (item && typeof item === "object" && item.word) {
        const validatedExamples = this.validateExamples(item.examples);
        const wordData = {
          word: item.word.toLowerCase(),
          pronunciation: item.pronunciation || "",
          meanings: Array.isArray(item.meanings) ? item.meanings : [],
          examples: validatedExamples,
          similarWords: Array.isArray(item.similarWords) ? item.similarWords : []
        };
        results.push(wordData);
      }
    }
    return results;
  }
  // JSON 문자열 복구
  fixJsonString(jsonString) {
    let fixed = jsonString;
    const lastCompleteObject = fixed.match(/.*\}(?=,?\s*$)/);
    if (lastCompleteObject) {
      fixed = lastCompleteObject[0] + "]";
    }
    fixed = fixed.replace(/,\s*,/g, ",");
    fixed = fixed.replace(/,\s*\]/g, "]");
    fixed = fixed.replace(/,\s*\}/g, "}");
    let result = "";
    let inString = false;
    let escaped = false;
    for (let i = 0; i < fixed.length; i++) {
      const char = fixed[i];
      const prevChar = i > 0 ? fixed[i - 1] : "";
      if (char === '"' && !escaped) {
        if (inString) {
          inString = false;
          result += char;
        } else {
          inString = true;
          result += char;
        }
      } else if (char === '"' && escaped) {
        result += char;
      } else if (char === '"' && inString && !escaped) {
        result += '\\"';
      } else {
        result += char;
      }
      escaped = char === "\\" && !escaped;
    }
    fixed = result;
    return fixed;
  }
};

// src/features/settings/ui/settings.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  defaultLanguage: "ko",
  showSimilarWords: true,
  showExamples: true,
  examplesCount: 3,
  openaiApiKey: "",
  anthropicApiKey: "",
  googleApiKey: "",
  llmProvider: "openai",
  llmModel: "gemini-1.0-pro-latest",
  enableAdvancedFeatures: false,
  reviewModalHeight: 85,
  vocabularyFolderPath: "Vocabulary",
  ttsEnabled: true,
  ttsProvider: "chatterbox",
  ttsVoice: "alloy",
  ttsPlaybackSpeed: 1,
  ttsAutoPlay: false,
  // Chatterbox TTS 기본값
  chatterboxApiUrl: "http://localhost:4123",
  // 경고: HTTP는 보안에 취약합니다. 가능하면 HTTPS를 사용하세요.
  chatterboxExaggeration: 0.7,
  chatterboxCfgWeight: 0.4,
  chatterboxTemperature: 0.9,
  // Google Cloud TTS 기본값
  googleCloudTTSApiKey: "",
  googleCloudTTSLanguageCode: "en-US",
  googleCloudTTSSpeakingRate: 1,
  googleCloudTTSPitch: 0,
  // TTS 캐시 설정
  ttsCacheEnabled: true
};
var VocabularySettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\uC601\uC5B4 \uB2E8\uC5B4 \uD559\uC2B5 \uD50C\uB7EC\uADF8\uC778 \uC124\uC815" });
    this.createBasicSettings(containerEl);
    this.createLLMSettings(containerEl);
    this.createTTSSettings(containerEl);
    this.createAdvancedSettings(containerEl);
  }
  createBasicSettings(containerEl) {
    containerEl.createEl("h3", { text: "\uAE30\uBCF8 \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uAE30\uBCF8 \uC5B8\uC5B4").setDesc("\uB2E8\uC5B4 \uB73B\uC744 \uD45C\uC2DC\uD560 \uC5B8\uC5B4\uB97C \uC120\uD0DD\uD558\uC138\uC694.").addDropdown((dropdown) => dropdown.addOption("ko", "\uD55C\uAD6D\uC5B4").addOption("en", "English").addOption("ja", "\u65E5\u672C\u8A9E").setValue(this.plugin.settings.defaultLanguage).onChange(async (value) => {
      this.plugin.settings.defaultLanguage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC720\uC0AC\uD55C \uB2E8\uC5B4 \uD45C\uC2DC").setDesc("\uD559\uC2B5\uD560 \uB54C \uC720\uC0AC\uD55C \uB2E8\uC5B4\uB4E4\uC744 \uD568\uAED8 \uD45C\uC2DC\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSimilarWords).onChange(async (value) => {
      this.plugin.settings.showSimilarWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC608\uBB38 \uD45C\uC2DC").setDesc("\uD559\uC2B5\uD560 \uB54C \uC608\uBB38\uB4E4\uC744 \uD568\uAED8 \uD45C\uC2DC\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showExamples).onChange(async (value) => {
      this.plugin.settings.showExamples = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC608\uBB38 \uAC1C\uC218").setDesc("\uD45C\uC2DC\uD560 \uC608\uBB38\uC758 \uAC1C\uC218\uB97C \uC124\uC815\uD558\uC138\uC694.").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.examplesCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.examplesCount = value;
      await this.plugin.saveSettings();
    }));
  }
  createLLMSettings(containerEl) {
    containerEl.createEl("h3", { text: "LLM API \uC124\uC815" });
    new import_obsidian2.Setting(containerEl).setName("\uACE0\uAE09 \uAE30\uB2A5 \uD65C\uC131\uD654").setDesc("LLM API\uB97C \uC0AC\uC6A9\uD55C \uACE0\uAE09 \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAdvancedFeatures).onChange(async (value) => {
      this.plugin.settings.enableAdvancedFeatures = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("LLM \uC81C\uACF5\uC5C5\uCCB4").setDesc("\uC0AC\uC6A9\uD560 LLM API \uC81C\uACF5\uC5C5\uCCB4\uB97C \uC120\uD0DD\uD558\uC138\uC694.").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI (GPT)").addOption("anthropic", "Anthropic (Claude)").addOption("google", "Google (Gemini)").setValue(this.plugin.settings.llmProvider).onChange(async (value) => {
      this.plugin.settings.llmProvider = value;
      if (value === "openai") {
        this.plugin.settings.llmModel = "gpt-4.1";
      } else if (value === "anthropic") {
        this.plugin.settings.llmModel = "claude-3-5-sonnet";
      } else if (value === "google") {
        this.plugin.settings.llmModel = "gemini-2.5-flash";
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    this.createModelSelection(containerEl);
    this.createApiKeySettings(containerEl);
    new import_obsidian2.Setting(containerEl).setName("API \uC5F0\uACB0 \uD14C\uC2A4\uD2B8").setDesc("\uD604\uC7AC \uC120\uD0DD\uB41C \uC81C\uACF5\uC5C5\uCCB4\uC758 API \uD0A4\uAC00 \uC62C\uBC14\uB974\uAC8C \uC124\uC815\uB418\uC5C8\uB294\uC9C0 \uD14C\uC2A4\uD2B8\uD569\uB2C8\uB2E4.").addButton((button) => button.setButtonText("\uD14C\uC2A4\uD2B8").onClick(async () => {
      button.setButtonText("\uD14C\uC2A4\uD2B8 \uC911...");
      button.setDisabled(true);
      try {
        const llmService = new LLMService(this.plugin.settings);
        const result = await llmService.testConnection();
        if (result.success) {
          new import_obsidian2.Notice("\u2705 API \uC5F0\uACB0 \uC131\uACF5!");
        } else {
          new import_obsidian2.Notice("\u274C API \uC5F0\uACB0 \uC2E4\uD328: " + result.error);
        }
      } catch (error) {
        new import_obsidian2.Notice("\u274C API \uC5F0\uACB0 \uC2E4\uD328: " + error.message);
      } finally {
        button.setButtonText("\uD14C\uC2A4\uD2B8");
        button.setDisabled(false);
      }
    }));
  }
  createModelSelection(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("API \uBAA8\uB378").setDesc("\uC0AC\uC6A9\uD560 LLM \uBAA8\uB378\uC744 \uC120\uD0DD\uD558\uC138\uC694.").addDropdown((dropdown) => {
      const provider = this.plugin.settings.llmProvider;
      if (provider === "openai") {
        dropdown.addOption("gpt-4.1", "GPT-4.1").addOption("gpt-4o", "GPT-4o").addOption("gpt-4o-mini", "GPT-4o Mini").addOption("gpt-4.1-long", "GPT-4.1 (Long Context)").addOption("gpt-4.5-preview", "GPT-4.5 Preview").addOption("gpt-4.5-preview-2", "GPT-4.5 Preview 2");
      } else if (provider === "anthropic") {
        dropdown.addOption("claude-3-5-sonnet", "Claude 3.5 Sonnet").addOption("claude-3-5-haiku", "Claude 3.5 Haiku").addOption("claude-3-5-opus", "Claude 3.5 Opus").addOption("claude-3-7-sonnet", "Claude 3.7 Sonnet").addOption("claude-3-7-haiku", "Claude 3.7 Haiku").addOption("claude-3-7-opus", "Claude 3.7 Opus").addOption("claude-3-5-flash", "Claude 3.5 Flash");
      } else if (provider === "google") {
        dropdown.addOption("gemini-1.5-pro-latest", "Gemini 1.5 Pro").addOption("gemini-2.5-flash", "Gemini 2.5 Flash").addOption("gemini-2.5-pro", "Gemini 2.5 Pro").addOption("gemini-1.5-flash-latest", "Gemini 1.5 Flash");
      }
      return dropdown.setValue(this.plugin.settings.llmModel).onChange(async (value) => {
        this.plugin.settings.llmModel = value;
        await this.plugin.saveSettings();
      });
    });
  }
  createApiKeySettings(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("OpenAI API \uD0A4").setDesc("OpenAI API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694. (sk-...\uB85C \uC2DC\uC791)").addText((text) => {
      const currentKey = this.plugin.settings.openaiApiKey;
      const decryptedKey = decryptApiKey(currentKey);
      const maskedKey = maskApiKey(decryptedKey);
      return text.setPlaceholder("sk-...").setValue(maskedKey).onChange(async (value) => {
        if (value !== maskedKey) {
          const encryptedKey = encryptApiKey(value);
          this.plugin.settings.openaiApiKey = encryptedKey;
          await this.plugin.saveSettings();
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Anthropic API \uD0A4").setDesc("Anthropic API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694. (sk-ant-...\uB85C \uC2DC\uC791)").addText((text) => {
      const currentKey = this.plugin.settings.anthropicApiKey;
      const decryptedKey = decryptApiKey(currentKey);
      const maskedKey = maskApiKey(decryptedKey);
      return text.setPlaceholder("sk-ant-...").setValue(maskedKey).onChange(async (value) => {
        if (value !== maskedKey) {
          const encryptedKey = encryptApiKey(value);
          this.plugin.settings.anthropicApiKey = encryptedKey;
          await this.plugin.saveSettings();
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Google API \uD0A4").setDesc("Google API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694.").addText((text) => {
      const currentKey = this.plugin.settings.googleApiKey;
      const decryptedKey = decryptApiKey(currentKey);
      const maskedKey = maskApiKey(decryptedKey);
      return text.setPlaceholder("AIza...").setValue(maskedKey).onChange(async (value) => {
        if (value !== maskedKey) {
          const encryptedKey = encryptApiKey(value);
          this.plugin.settings.googleApiKey = encryptedKey;
          await this.plugin.saveSettings();
        }
      });
    });
  }
  createAdvancedSettings(containerEl) {
    containerEl.createEl("h3", { text: "\uACE0\uAE09 \uC124\uC815" });
    const folders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian2.TFolder);
    new import_obsidian2.Setting(containerEl).setName("\uB2E8\uC5B4\uC7A5 \uC800\uC7A5 \uD3F4\uB354").setDesc("\uB2E8\uC5B4\uC7A5 \uD30C\uC77C\uB4E4\uC774 \uC800\uC7A5\uB420 \uD3F4\uB354\uB97C \uC120\uD0DD\uD558\uC138\uC694. (\uAE30\uBCF8\uAC12: Vocabulary)").addDropdown((dropdown) => {
      folders.forEach((folder) => {
        if (folder instanceof import_obsidian2.TFolder) {
          dropdown.addOption(folder.path, folder.path);
        }
      });
      dropdown.setValue(this.plugin.settings.vocabularyFolderPath);
      dropdown.onChange(async (value) => {
        this.plugin.settings.vocabularyFolderPath = value;
        await this.plugin.saveSettings();
        if (this.plugin.databaseManager) {
          this.plugin.databaseManager.updateVocabularyFolderPath(value);
        }
      });
      return dropdown;
    });
    new import_obsidian2.Setting(containerEl).setName("\uBCF5\uC2B5 \uD654\uBA74 \uB192\uC774").setDesc("\uBCF5\uC2B5 \uBAA8\uB2EC\uC758 \uB192\uC774\uB97C \uD654\uBA74 \uB192\uC774\uC758 \uBC31\uBD84\uC728\uB85C \uC124\uC815\uD558\uC138\uC694. (\uAE30\uBCF8\uAC12: 85%)").addSlider((slider) => slider.setLimits(50, 95, 5).setValue(this.plugin.settings.reviewModalHeight).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.reviewModalHeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC77C\uC77C \uD559\uC2B5 \uBAA9\uD45C").setDesc("\uD558\uB8E8\uC5D0 \uD559\uC2B5\uD560 \uB2E8\uC5B4\uC758 \uBAA9\uD45C \uAC1C\uC218\uB97C \uC124\uC815\uD558\uC138\uC694.").addSlider((slider) => {
      var _a, _b, _c;
      return slider.setLimits(5, 50, 5).setValue(((_c = (_b = (_a = this.plugin.databaseManager) == null ? void 0 : _a.getDataForSave()) == null ? void 0 : _b.settings) == null ? void 0 : _c.dailyGoal) || 10).setDynamicTooltip().onChange(async (value) => {
        var _a2;
        await ((_a2 = this.plugin.databaseManager) == null ? void 0 : _a2.updateSettings({ dailyGoal: value }));
      });
    });
    new import_obsidian2.Setting(containerEl).setName("\uBCF5\uC2B5 \uAC04\uACA9 (\uC77C)").setDesc("\uB2E8\uC5B4\uB97C \uB2E4\uC2DC \uBCF5\uC2B5\uD560 \uAC04\uACA9\uC744 \uC124\uC815\uD558\uC138\uC694.").addSlider((slider) => {
      var _a, _b, _c;
      return slider.setLimits(1, 30, 1).setValue(((_c = (_b = (_a = this.plugin.databaseManager) == null ? void 0 : _a.getDataForSave()) == null ? void 0 : _b.settings) == null ? void 0 : _c.reviewInterval) || 1).setDynamicTooltip().onChange(async (value) => {
        var _a2;
        await ((_a2 = this.plugin.databaseManager) == null ? void 0 : _a2.updateSettings({ reviewInterval: value }));
      });
    });
  }
  createTTSSettings(containerEl) {
    containerEl.createEl("h3", { text: "TTS (\uC74C\uC131 \uC77D\uAE30) \uC124\uC815" });
    const ttsToggleSetting = new import_obsidian2.Setting(containerEl).setName("TTS \uD65C\uC131\uD654").setDesc("\uB2E8\uC5B4\uC640 \uC608\uBB38\uC744 \uC74C\uC131\uC73C\uB85C \uC77D\uC5B4\uC8FC\uB294 \uAE30\uB2A5\uC744 \uD65C\uC131\uD654\uD569\uB2C8\uB2E4.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ttsEnabled).onChange(async (value) => {
      this.plugin.settings.ttsEnabled = value;
      await this.plugin.saveSettings();
      this.updateTTSSettingsVisibility();
    }));
    new import_obsidian2.Setting(containerEl).setName("TTS \uC81C\uACF5\uC790").setDesc("\uC0AC\uC6A9\uD560 TTS \uC11C\uBE44\uC2A4\uB97C \uC120\uD0DD\uD558\uC138\uC694.").setClass("tts-provider-setting").addDropdown((dropdown) => dropdown.addOption("chatterbox", "Chatterbox TTS (\uB85C\uCEEC)").addOption("google-cloud", "Google Cloud Text-to-Speech").setValue(this.plugin.settings.ttsProvider).onChange(async (value) => {
      this.plugin.settings.ttsProvider = value;
      await this.plugin.saveSettings();
      this.updateTTSProviderSettings();
    }));
    this.createChatterboxTTSSettings(containerEl);
    this.createGoogleCloudTTSSettings(containerEl);
    const autoPlaySetting = new import_obsidian2.Setting(containerEl).setName("\uC790\uB3D9 \uC7AC\uC0DD").setDesc("\uB2E8\uC5B4 \uCE74\uB4DC\uAC00 \uD45C\uC2DC\uB420 \uB54C \uC790\uB3D9\uC73C\uB85C \uB2E8\uC5B4\uB97C \uC77D\uC5B4\uC90D\uB2C8\uB2E4.").setClass("tts-autoplay-setting").addToggle((toggle) => toggle.setValue(this.plugin.settings.ttsAutoPlay).onChange(async (value) => {
      this.plugin.settings.ttsAutoPlay = value;
      await this.plugin.saveSettings();
    }));
    this.createTTSCacheSettings(containerEl);
    this.updateTTSSettingsVisibility();
    this.updateTTSProviderSettings();
  }
  populateChatterboxVoiceDropdown(dropdown) {
    const chatterboxVoices = [
      { value: "alloy", name: "Alloy (\uC911\uC131\uC801)" },
      { value: "echo", name: "Echo (\uB0A8\uC131)" },
      { value: "fable", name: "Fable (\uC601\uAD6D\uC2DD)" },
      { value: "onyx", name: "Onyx (\uAE4A\uC740 \uB0A8\uC131)" },
      { value: "nova", name: "Nova (\uC5EC\uC131)" },
      { value: "shimmer", name: "Shimmer (\uBD80\uB4DC\uB7EC\uC6B4 \uC5EC\uC131)" },
      { value: "custom", name: "Custom (\uC0AC\uC6A9\uC790 \uC815\uC758)" }
    ];
    chatterboxVoices.forEach((option) => {
      dropdown.addOption(option.value, option.name);
    });
    try {
      const voices = speechSynthesis.getVoices();
      const englishVoices = voices.filter(
        (voice) => voice.lang.startsWith("en-") && !voice.lang.includes("ko") && !chatterboxVoices.some((opt) => opt.value === voice.name)
      );
      if (englishVoices.length > 0) {
        dropdown.addOption("---", "--- \uC2DC\uC2A4\uD15C \uC74C\uC131 ---");
        englishVoices.forEach((voice) => {
          const displayName = `${voice.name} (${voice.lang})`;
          dropdown.addOption(voice.name, displayName);
        });
      }
    } catch (error) {
      console.warn("\uC74C\uC131 \uBAA9\uB85D\uC744 \uAC00\uC838\uC624\uB294 \uC911 \uC624\uB958:", error);
    }
  }
  updateTTSSettingsVisibility() {
    const isEnabled = this.plugin.settings.ttsEnabled;
    const allTtsSettings = this.containerEl.querySelectorAll(
      ".tts-provider-setting, .chatterbox-api-url-setting, .chatterbox-voice-setting, .chatterbox-exaggeration-setting, .chatterbox-cfg-setting, .chatterbox-temperature-setting, .google-cloud-tts-guide, .google-cloud-api-key-setting, .google-cloud-language-setting, .google-cloud-voice-setting, .google-cloud-speaking-rate-setting, .google-cloud-pitch-setting, .tts-autoplay-setting, .tts-cache-header, .tts-cache-enabled-setting, .tts-cache-info-setting, .tts-cache-clear-setting"
    );
    allTtsSettings.forEach((setting) => {
      const element = setting;
      if (isEnabled) {
        element.removeClass("settings-disabled");
        element.addClass("settings-enabled");
        const buttons = element.querySelectorAll("button");
        const dropdowns = element.querySelectorAll("select");
        const sliders = element.querySelectorAll('input[type="range"]');
        const toggles = element.querySelectorAll('input[type="checkbox"]');
        const inputs = element.querySelectorAll('input[type="text"]');
        buttons.forEach((btn) => btn.disabled = false);
        dropdowns.forEach((dd) => dd.disabled = false);
        sliders.forEach((slider) => slider.disabled = false);
        toggles.forEach((toggle) => toggle.disabled = false);
        inputs.forEach((input) => input.disabled = false);
      } else {
        element.removeClass("settings-enabled");
        element.addClass("settings-disabled");
        const buttons = element.querySelectorAll("button");
        const dropdowns = element.querySelectorAll("select");
        const sliders = element.querySelectorAll('input[type="range"]');
        const toggles = element.querySelectorAll('input[type="checkbox"]');
        const inputs = element.querySelectorAll('input[type="text"]');
        buttons.forEach((btn) => btn.disabled = true);
        dropdowns.forEach((dd) => dd.disabled = true);
        sliders.forEach((slider) => slider.disabled = true);
        toggles.forEach((toggle) => toggle.disabled = true);
        inputs.forEach((input) => input.disabled = true);
      }
    });
    if (isEnabled) {
      this.updateTTSProviderSettings();
    }
  }
  async testChatterboxConnection() {
    try {
      const response = await fetch(`${this.plugin.settings.chatterboxApiUrl}/v1/audio/speech`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: "Connection test",
          voice: "alloy"
        })
      });
      if (response.ok) {
        new import_obsidian2.Notice("\u2705 Chatterbox TTS \uC11C\uBC84 \uC5F0\uACB0 \uC131\uACF5!");
      } else {
        throw new Error(`\uC11C\uBC84 \uC751\uB2F5 \uC624\uB958: ${response.status}`);
      }
    } catch (error) {
      console.error("Chatterbox TTS \uC5F0\uACB0 \uD14C\uC2A4\uD2B8 \uC2E4\uD328:", error);
      new import_obsidian2.Notice("\u274C Chatterbox TTS \uC11C\uBC84 \uC5F0\uACB0 \uC2E4\uD328. \uC11C\uBC84\uAC00 \uC2E4\uD589 \uC911\uC778\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      throw error;
    }
  }
  createChatterboxTTSSettings(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Chatterbox TTS API URL").setDesc("Chatterbox TTS \uC11C\uBC84\uC758 URL\uC744 \uC785\uB825\uD558\uC138\uC694. (\uAE30\uBCF8\uAC12: http://localhost:4123)").setClass("chatterbox-api-url-setting").addText((text) => text.setPlaceholder("http://localhost:4123").setValue(this.plugin.settings.chatterboxApiUrl).onChange(async (value) => {
      this.plugin.settings.chatterboxApiUrl = value || "http://localhost:4123";
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("\uC5F0\uACB0 \uD14C\uC2A4\uD2B8").setTooltip("Chatterbox TTS \uC11C\uBC84 \uC5F0\uACB0\uC744 \uD14C\uC2A4\uD2B8\uD569\uB2C8\uB2E4").onClick(async () => {
      button.setButtonText("\uD14C\uC2A4\uD2B8 \uC911...");
      button.setDisabled(true);
      try {
        await this.testChatterboxConnection();
      } finally {
        button.setButtonText("\uC5F0\uACB0 \uD14C\uC2A4\uD2B8");
        button.setDisabled(false);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC74C\uC131 \uC120\uD0DD").setDesc("Chatterbox TTS\uC5D0\uC11C \uC0AC\uC6A9\uD560 \uC74C\uC131\uC744 \uC120\uD0DD\uD558\uC138\uC694.").setClass("chatterbox-voice-setting").addDropdown((dropdown) => {
      this.populateChatterboxVoiceDropdown(dropdown);
      return dropdown.setValue(this.plugin.settings.ttsVoice).onChange(async (value) => {
        this.plugin.settings.ttsVoice = value;
        await this.plugin.saveSettings();
      });
    }).addButton((button) => button.setButtonText("\uBBF8\uB9AC\uB4E3\uAE30").setTooltip("\uC120\uD0DD\uD55C \uC74C\uC131\uC73C\uB85C \uC0D8\uD50C \uD14D\uC2A4\uD2B8\uB97C \uC7AC\uC0DD\uD569\uB2C8\uB2E4").onClick(async () => {
      button.setButtonText("\uC7AC\uC0DD \uC911...");
      button.setDisabled(true);
      try {
        await this.playChatterboxVoicePreview();
      } catch (error) {
        console.error("\uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30 \uC624\uB958:", error);
        new import_obsidian2.Notice("\uC74C\uC131 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
      } finally {
        button.setButtonText("\uBBF8\uB9AC\uB4E3\uAE30");
        button.setDisabled(false);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\uAC10\uC815 \uD45C\uD604 \uAC15\uB3C4 (Exaggeration)").setDesc("\uC74C\uC131\uC758 \uAC10\uC815 \uD45C\uD604 \uAC15\uB3C4\uB97C \uC870\uC808\uD569\uB2C8\uB2E4. (0.25 = \uC57D\uD568, 2.0 = \uAC15\uD568)").setClass("chatterbox-exaggeration-setting").addSlider((slider) => slider.setLimits(0.25, 2, 0.05).setValue(this.plugin.settings.chatterboxExaggeration).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chatterboxExaggeration = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("CFG \uAC00\uC911\uCE58 (CFG Weight)").setDesc("\uC74C\uC131 \uC0DD\uC131\uC758 \uAC00\uC774\uB358\uC2A4 \uAC15\uB3C4\uB97C \uC870\uC808\uD569\uB2C8\uB2E4. (0.0 = \uC57D\uD568, 1.0 = \uAC15\uD568)").setClass("chatterbox-cfg-setting").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.chatterboxCfgWeight).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chatterboxCfgWeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC628\uB3C4 (Temperature)").setDesc("\uC74C\uC131 \uC0DD\uC131\uC758 \uCC3D\uC758\uC131\uC744 \uC870\uC808\uD569\uB2C8\uB2E4. (0.05 = \uC77C\uAD00\uC131, 5.0 = \uCC3D\uC758\uC131)").setClass("chatterbox-temperature-setting").addSlider((slider) => slider.setLimits(0.05, 5, 0.05).setValue(this.plugin.settings.chatterboxTemperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.chatterboxTemperature = value;
      await this.plugin.saveSettings();
    }));
  }
  createGoogleCloudTTSSettings(containerEl) {
    const guideEl = containerEl.createEl("div", {
      cls: "google-cloud-tts-guide google-cloud-api-key-setting",
      attr: { style: "margin-bottom: 15px; padding: 10px; background-color: var(--background-secondary); border-radius: 5px; border-left: 3px solid var(--interactive-accent);" }
    });
    guideEl.createEl("h4", { text: "\u{1F527} Google Cloud TTS \uC124\uC815 \uAC00\uC774\uB4DC", attr: { style: "margin: 0 0 10px 0; color: var(--interactive-accent);" } });
    const stepsList = guideEl.createEl("ol", { attr: { style: "margin: 0; padding-left: 20px; line-height: 1.6;" } });
    const step1 = stepsList.createEl("li");
    step1.createEl("strong", { text: "Google Cloud Console \uC811\uC18D:" });
    step1.appendText(" ");
    const step1Link = step1.createEl("a", {
      text: "console.cloud.google.com",
      href: "https://console.cloud.google.com",
      attr: { style: "color: var(--interactive-accent);" }
    });
    step1Link.addEventListener("click", () => {
      window.open("https://console.cloud.google.com", "_blank");
    });
    const step2 = stepsList.createEl("li");
    step2.createEl("strong", { text: "\uD504\uB85C\uC81D\uD2B8 \uC120\uD0DD/\uC0DD\uC131:" });
    step2.appendText(" \uAE30\uC874 \uD504\uB85C\uC81D\uD2B8\uB97C \uC120\uD0DD\uD558\uAC70\uB098 \uC0C8 \uD504\uB85C\uC81D\uD2B8\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4.");
    const step3 = stepsList.createEl("li");
    step3.createEl("strong", { text: "Text-to-Speech API \uD65C\uC131\uD654:" });
    step3.appendText(" ");
    const step3Link = step3.createEl("a", {
      text: "API \uB77C\uC774\uBE0C\uB7EC\uB9AC\uC5D0\uC11C \uD65C\uC131\uD654",
      href: "https://console.cloud.google.com/apis/library/texttospeech.googleapis.com",
      attr: { style: "color: var(--interactive-accent);" }
    });
    step3Link.addEventListener("click", () => {
      window.open("https://console.cloud.google.com/apis/library/texttospeech.googleapis.com", "_blank");
    });
    const step4 = stepsList.createEl("li");
    step4.createEl("strong", { text: "API \uD0A4 \uC0DD\uC131:" });
    step4.appendText(" \uC0AC\uC6A9\uC790 \uC778\uC99D \uC815\uBCF4 > API \uD0A4 > \uC0C8 API \uD0A4 \uC0DD\uC131");
    const step5 = stepsList.createEl("li");
    step5.createEl("strong", { text: "API \uD0A4 \uC81C\uD55C \uC124\uC815 (\uAD8C\uC7A5):" });
    step5.appendText(" \uD0A4 \uC81C\uD55C > API \uC81C\uD55C > Cloud Text-to-Speech API \uC120\uD0DD");
    const warningEl = guideEl.createEl("div", {
      attr: { style: "margin-top: 10px; padding: 8px; background-color: var(--background-modifier-error-rgb); border-radius: 3px; font-size: 0.9em;" }
    });
    warningEl.appendText("\u26A0\uFE0F ");
    warningEl.createEl("strong", { text: "\uC911\uC694:" });
    warningEl.appendText(' Text-to-Speech API\uAC00 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC740 \uACBD\uC6B0 "API_KEY_SERVICE_BLOCKED" \uC624\uB958\uAC00 \uBC1C\uC0DD\uD569\uB2C8\uB2E4.');
    new import_obsidian2.Setting(containerEl).setName("Google Cloud TTS API \uD0A4").setDesc("Google Cloud Text-to-Speech API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694.").setClass("google-cloud-api-key-setting").addText((text) => {
      const currentKey = this.plugin.settings.googleCloudTTSApiKey;
      const decryptedKey = decryptApiKey(currentKey);
      const maskedKey = maskApiKey(decryptedKey);
      return text.setPlaceholder("AIza...").setValue(maskedKey).onChange(async (value) => {
        if (value !== maskedKey) {
          const encryptedKey = encryptApiKey(value);
          this.plugin.settings.googleCloudTTSApiKey = encryptedKey;
          await this.plugin.saveSettings();
        }
      });
    }).addButton((button) => button.setButtonText("\uC5F0\uACB0 \uD14C\uC2A4\uD2B8").setTooltip("Google Cloud TTS API \uC5F0\uACB0\uC744 \uD14C\uC2A4\uD2B8\uD569\uB2C8\uB2E4").onClick(async () => {
      button.setButtonText("\uD14C\uC2A4\uD2B8 \uC911...");
      button.setDisabled(true);
      try {
        await this.testGoogleCloudConnection();
      } finally {
        button.setButtonText("\uC5F0\uACB0 \uD14C\uC2A4\uD2B8");
        button.setDisabled(false);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC5B8\uC5B4 \uCF54\uB4DC").setDesc("\uC0AC\uC6A9\uD560 \uC5B8\uC5B4 \uCF54\uB4DC\uB97C \uC120\uD0DD\uD558\uC138\uC694.").setClass("google-cloud-language-setting").addDropdown((dropdown) => dropdown.addOption("en-US", "English (US)").addOption("en-GB", "English (UK)").addOption("en-AU", "English (AU)").addOption("en-IN", "English (India)").setValue(this.plugin.settings.googleCloudTTSLanguageCode).onChange(async (value) => {
      this.plugin.settings.googleCloudTTSLanguageCode = value;
      await this.plugin.saveSettings();
      this.updateGoogleCloudVoices();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC74C\uC131 \uC120\uD0DD").setDesc("Google Cloud TTS\uC5D0\uC11C \uC0AC\uC6A9\uD560 \uC74C\uC131\uC744 \uC120\uD0DD\uD558\uC138\uC694.").setClass("google-cloud-voice-setting").addDropdown((dropdown) => {
      this.populateGoogleCloudVoiceDropdown(dropdown);
      return dropdown.setValue(this.plugin.settings.ttsVoice).onChange(async (value) => {
        this.plugin.settings.ttsVoice = value;
        await this.plugin.saveSettings();
      });
    }).addButton((button) => button.setButtonText("\uBBF8\uB9AC\uB4E3\uAE30").setTooltip("\uC120\uD0DD\uD55C \uC74C\uC131\uC73C\uB85C \uC0D8\uD50C \uD14D\uC2A4\uD2B8\uB97C \uC7AC\uC0DD\uD569\uB2C8\uB2E4").onClick(async () => {
      button.setButtonText("\uC7AC\uC0DD \uC911...");
      button.setDisabled(true);
      try {
        await this.playGoogleCloudVoicePreview();
      } catch (error) {
        console.error("\uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30 \uC624\uB958:", error);
        new import_obsidian2.Notice("\uC74C\uC131 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
      } finally {
        button.setButtonText("\uBBF8\uB9AC\uB4E3\uAE30");
        button.setDisabled(false);
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("\uB9D0\uD558\uAE30 \uC18D\uB3C4 (Speaking Rate)").setDesc("\uC74C\uC131\uC758 \uB9D0\uD558\uAE30 \uC18D\uB3C4\uB97C \uC870\uC808\uD569\uB2C8\uB2E4. (0.25 = \uB290\uB9BC, 4.0 = \uBE60\uB984)").setClass("google-cloud-speaking-rate-setting").addSlider((slider) => slider.setLimits(0.25, 4, 0.25).setValue(this.plugin.settings.googleCloudTTSSpeakingRate).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.googleCloudTTSSpeakingRate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\uC74C\uC131 \uB192\uB0AE\uC774 (Pitch)").setDesc("\uC74C\uC131\uC758 \uB192\uB0AE\uC774\uB97C \uC870\uC808\uD569\uB2C8\uB2E4. (-20.0 = \uB0AE\uC74C, 20.0 = \uB192\uC74C)").setClass("google-cloud-pitch-setting").addSlider((slider) => slider.setLimits(-20, 20, 1).setValue(this.plugin.settings.googleCloudTTSPitch).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.googleCloudTTSPitch = value;
      await this.plugin.saveSettings();
    }));
  }
  populateGoogleCloudVoiceDropdown(dropdown) {
    const languageCode = this.plugin.settings.googleCloudTTSLanguageCode;
    if (languageCode === "en-US") {
      dropdown.addOption("en-US-Journey-D", "Journey-D (Male)").addOption("en-US-Journey-F", "Journey-F (Female)").addOption("en-US-Journey-O", "Journey-O (Male)").addOption("en-US-Neural2-A", "Neural2-A (Male)").addOption("en-US-Neural2-C", "Neural2-C (Female)").addOption("en-US-Neural2-D", "Neural2-D (Male)").addOption("en-US-Neural2-E", "Neural2-E (Female)").addOption("en-US-Neural2-F", "Neural2-F (Female)").addOption("en-US-Neural2-G", "Neural2-G (Female)").addOption("en-US-Neural2-H", "Neural2-H (Female)").addOption("en-US-Neural2-I", "Neural2-I (Male)").addOption("en-US-Neural2-J", "Neural2-J (Male)");
    } else if (languageCode === "en-GB") {
      dropdown.addOption("en-GB-Neural2-A", "Neural2-A (Female)").addOption("en-GB-Neural2-B", "Neural2-B (Male)").addOption("en-GB-Neural2-C", "Neural2-C (Female)").addOption("en-GB-Neural2-D", "Neural2-D (Male)").addOption("en-GB-Neural2-F", "Neural2-F (Female)");
    } else if (languageCode === "en-AU") {
      dropdown.addOption("en-AU-Neural2-A", "Neural2-A (Female)").addOption("en-AU-Neural2-B", "Neural2-B (Male)").addOption("en-AU-Neural2-C", "Neural2-C (Female)").addOption("en-AU-Neural2-D", "Neural2-D (Male)");
    } else {
      dropdown.addOption("en-US-Journey-F", "Journey-F (Female)");
    }
  }
  updateGoogleCloudVoices() {
    const voiceDropdown = this.containerEl.querySelector(".google-cloud-voice-setting select");
    if (voiceDropdown) {
      voiceDropdown.empty();
      const dropdown = { addOption: (value, text) => {
        const option = document.createElement("option");
        option.value = value;
        option.text = text;
        voiceDropdown.appendChild(option);
      } };
      this.populateGoogleCloudVoiceDropdown(dropdown);
      const languageCode = this.plugin.settings.googleCloudTTSLanguageCode;
      let defaultVoice = "en-US-Journey-F";
      if (languageCode === "en-GB")
        defaultVoice = "en-GB-Neural2-A";
      else if (languageCode === "en-AU")
        defaultVoice = "en-AU-Neural2-A";
      voiceDropdown.value = defaultVoice;
      this.plugin.settings.ttsVoice = defaultVoice;
      this.plugin.saveSettings();
    }
  }
  updateTTSProviderSettings() {
    const provider = this.plugin.settings.ttsProvider;
    const chatterboxSettings = this.containerEl.querySelectorAll(".chatterbox-api-url-setting, .chatterbox-voice-setting, .chatterbox-exaggeration-setting, .chatterbox-cfg-setting, .chatterbox-temperature-setting");
    const googleCloudSettings = this.containerEl.querySelectorAll(".google-cloud-tts-guide, .google-cloud-api-key-setting, .google-cloud-language-setting, .google-cloud-voice-setting, .google-cloud-speaking-rate-setting, .google-cloud-pitch-setting");
    chatterboxSettings.forEach((setting) => {
      setting.style.display = "none";
    });
    googleCloudSettings.forEach((setting) => {
      setting.style.display = "none";
    });
    if (provider === "chatterbox") {
      chatterboxSettings.forEach((setting) => {
        setting.style.display = "";
      });
    } else if (provider === "google-cloud") {
      googleCloudSettings.forEach((setting) => {
        setting.style.display = "";
      });
    }
  }
  async playChatterboxVoicePreview() {
    try {
      const sampleTexts = [
        "Hello, this is a sample voice preview.",
        "Welcome to English vocabulary learning.",
        "This voice will help you learn pronunciation.",
        "Beautiful words make beautiful sentences."
      ];
      const randomText = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
      const response = await fetch(`${this.plugin.settings.chatterboxApiUrl}/v1/audio/speech`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: randomText,
          voice: this.plugin.settings.ttsVoice,
          exaggeration: this.plugin.settings.chatterboxExaggeration,
          cfg_weight: this.plugin.settings.chatterboxCfgWeight,
          temperature: this.plugin.settings.chatterboxTemperature
        })
      });
      if (!response.ok) {
        throw new Error(`Chatterbox TTS API \uC624\uB958: ${response.status} ${response.statusText}`);
      }
      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      return new Promise((resolve, reject) => {
        audio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          new import_obsidian2.Notice("\uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30 \uC644\uB8CC!");
          resolve();
        };
        audio.onerror = () => {
          URL.revokeObjectURL(audioUrl);
          reject(new Error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."));
        };
        audio.play().catch(reject);
      });
    } catch (error) {
      console.error("Chatterbox TTS \uBBF8\uB9AC\uB4E3\uAE30 \uC624\uB958:", error);
      new import_obsidian2.Notice("\uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. Chatterbox TTS \uC11C\uBC84\uAC00 \uC2E4\uD589 \uC911\uC778\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      throw error;
    }
  }
  async playGoogleCloudVoicePreview() {
    try {
      const sampleTexts = [
        "Hello, this is a sample voice preview.",
        "Welcome to English vocabulary learning.",
        "This voice will help you learn pronunciation.",
        "Beautiful words make beautiful sentences."
      ];
      const randomText = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
      const apiKey = decryptApiKey(this.plugin.settings.googleCloudTTSApiKey);
      if (!apiKey) {
        throw new Error("Google Cloud TTS API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      }
      const requestBody = {
        input: { text: randomText },
        voice: {
          languageCode: this.plugin.settings.googleCloudTTSLanguageCode,
          name: this.plugin.settings.ttsVoice
        },
        audioConfig: {
          audioEncoding: "MP3",
          speakingRate: this.plugin.settings.googleCloudTTSSpeakingRate,
          pitch: this.plugin.settings.googleCloudTTSPitch
        }
      };
      const response = await (0, import_obsidian2.requestUrl)({
        url: `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status >= 400) {
        const errorData = JSON.parse(response.text || "{}");
        const detailedError = this.getDetailedGoogleCloudError(response.status, errorData);
        throw new Error(detailedError);
      }
      const data = JSON.parse(response.text);
      const audioBlob = this.base64ToBlob(data.audioContent, "audio/mp3");
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      return new Promise((resolve, reject) => {
        audio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          new import_obsidian2.Notice("\uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30 \uC644\uB8CC!");
          resolve();
        };
        audio.onerror = () => {
          URL.revokeObjectURL(audioUrl);
          reject(new Error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."));
        };
        audio.play().catch(reject);
      });
    } catch (error) {
      console.error("Google Cloud TTS \uBBF8\uB9AC\uB4E3\uAE30 \uC624\uB958:", error);
      if (error.message.includes("API\uAC00 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4")) {
        new import_obsidian2.Notice(`\u274C ${error.message}`);
      } else if (error.message.includes("API \uD0A4")) {
        new import_obsidian2.Notice(`\u274C ${error.message}`);
      } else {
        new import_obsidian2.Notice("\u274C \uC74C\uC131 \uBBF8\uB9AC\uB4E3\uAE30\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. API \uD0A4\uC640 \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      }
      throw error;
    }
  }
  base64ToBlob(base64, mimeType) {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType });
  }
  async testGoogleCloudConnection() {
    try {
      const apiKey = decryptApiKey(this.plugin.settings.googleCloudTTSApiKey);
      if (!apiKey) {
        new import_obsidian2.Notice("\u274C Google Cloud TTS API \uD0A4\uB97C \uBA3C\uC800 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
        return;
      }
      const response = await (0, import_obsidian2.requestUrl)({
        url: `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: { text: "Connection test" },
          voice: {
            languageCode: "en-US",
            name: "en-US-Journey-F"
          },
          audioConfig: {
            audioEncoding: "MP3"
          }
        })
      });
      if (response.status < 400) {
        new import_obsidian2.Notice("\u2705 Google Cloud TTS API \uC5F0\uACB0 \uC131\uACF5!");
      } else {
        const errorData = JSON.parse(response.text || "{}");
        const detailedError = this.getDetailedGoogleCloudError(response.status, errorData);
        new import_obsidian2.Notice(`\u274C ${detailedError}`);
      }
    } catch (error) {
      console.error("Google Cloud TTS \uC5F0\uACB0 \uD14C\uC2A4\uD2B8 \uC2E4\uD328:", error);
      if (error.message.includes("\uB124\uD2B8\uC6CC\uD06C") || error.message.includes("fetch")) {
        new import_obsidian2.Notice("\u274C \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      } else {
        new import_obsidian2.Notice(`\u274C ${error.message}`);
      }
    }
  }
  getDetailedGoogleCloudError(status, errorData) {
    var _a, _b, _c, _d;
    if (errorData == null ? void 0 : errorData.error) {
      const error = errorData.error;
      if (status === 403 && ((_a = error.details) == null ? void 0 : _a.some(
        (detail) => {
          var _a2;
          return detail.reason === "API_KEY_SERVICE_BLOCKED" || ((_a2 = detail["@type"]) == null ? void 0 : _a2.includes("ErrorInfo")) && detail.reason === "API_KEY_SERVICE_BLOCKED";
        }
      ))) {
        return "Text-to-Speech API\uAC00 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC704\uC758 \uAC00\uC774\uB4DC\uB97C \uCC38\uACE0\uD558\uC5EC API\uB97C \uD65C\uC131\uD654\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 403) {
        if (((_b = error.message) == null ? void 0 : _b.includes("API key not valid")) || error.code === "INVALID_ARGUMENT") {
          return "API \uD0A4\uAC00 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uD0A4\uB97C \uB2E4\uC2DC \uD655\uC778\uD574\uC8FC\uC138\uC694.";
        }
        if (((_c = error.message) == null ? void 0 : _c.includes("quota")) || ((_d = error.message) == null ? void 0 : _d.includes("QUOTA_EXCEEDED"))) {
          return "API \uD560\uB2F9\uB7C9\uC774 \uCD08\uACFC\uB418\uC5C8\uC2B5\uB2C8\uB2E4. Google Cloud Console\uC5D0\uC11C \uD560\uB2F9\uB7C9\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
        }
        return "API \uC811\uADFC\uC774 \uAC70\uBD80\uB418\uC5C8\uC2B5\uB2C8\uB2E4. API \uD0A4 \uAD8C\uD55C\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 401) {
        return "API \uD0A4 \uC778\uC99D\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. API \uD0A4\uAC00 \uC62C\uBC14\uB978\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 400) {
        return "API \uC694\uCCAD\uC774 \uC798\uBABB\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC74C\uC131 \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 503) {
        return "Google Cloud TTS \uC11C\uBE44\uC2A4\uAC00 \uC77C\uC2DC\uC801\uC73C\uB85C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.";
      }
      return `API \uC624\uB958 (${status}): ${error.message || "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958"}`;
    }
    return `API \uC624\uB958: ${status} \uC0C1\uD0DC \uCF54\uB4DC`;
  }
  createTTSCacheSettings(containerEl) {
    const cacheHeaderEl = containerEl.createEl("div", {
      cls: "tts-cache-header",
      attr: { style: "margin-top: 20px; padding: 10px; background-color: var(--background-secondary); border-radius: 5px; border-left: 3px solid var(--interactive-accent);" }
    });
    cacheHeaderEl.createEl("h4", { text: "\u{1F5C2}\uFE0F TTS \uCE90\uC2DC \uAD00\uB9AC", attr: { style: "margin: 0 0 5px 0; color: var(--interactive-accent);" } });
    cacheHeaderEl.createEl("p", { text: "\uC74C\uC131 \uD30C\uC77C\uC744 \uB85C\uCEEC\uC5D0 \uCE90\uC2DC\uD558\uC5EC API \uBE44\uC6A9\uC744 \uC808\uC57D\uD558\uACE0 \uC751\uB2F5 \uC18D\uB3C4\uB97C \uD5A5\uC0C1\uC2DC\uD0B5\uB2C8\uB2E4. \uC544\uB798\uC5D0\uC11C \uD604\uC7AC \uCE90\uC2DC \uD3F4\uB354\uC758 \uC6A9\uB7C9\uACFC \uD30C\uC77C \uC218\uB97C \uD655\uC778\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.", attr: { style: "margin: 0; font-size: 0.9em; opacity: 0.8;" } });
    new import_obsidian2.Setting(containerEl).setName("TTS \uCE90\uC2DC \uD65C\uC131\uD654").setDesc("TTS \uC74C\uC131 \uD30C\uC77C\uC744 \uB85C\uCEEC\uC5D0 \uCE90\uC2DC\uD558\uC5EC \uC7AC\uC0AC\uC6A9\uD569\uB2C8\uB2E4.").setClass("tts-cache-enabled-setting").addToggle((toggle) => toggle.setValue(this.plugin.settings.ttsCacheEnabled).onChange(async (value) => {
      this.plugin.settings.ttsCacheEnabled = value;
      await this.plugin.saveSettings();
    }));
    const cacheInfoSetting = new import_obsidian2.Setting(containerEl).setName("\u{1F4CA} \uCE90\uC2DC \uD604\uD669").setDesc("\uCE90\uC2DC \uC815\uBCF4\uB97C \uBD88\uB7EC\uC624\uB294 \uC911...").setClass("tts-cache-info-setting");
    this.updateCacheInfo(cacheInfoSetting);
    new import_obsidian2.Setting(containerEl).setName("\uCE90\uC2DC \uAD00\uB9AC").setDesc("\uC800\uC7A5\uB41C \uBAA8\uB4E0 TTS \uCE90\uC2DC \uD30C\uC77C\uC744 \uC0AD\uC81C\uD569\uB2C8\uB2E4.").setClass("tts-cache-clear-setting").addButton((button) => button.setButtonText("\uCE90\uC2DC \uC0AD\uC81C").setTooltip("\uBAA8\uB4E0 TTS \uCE90\uC2DC \uD30C\uC77C\uC744 \uC0AD\uC81C\uD569\uB2C8\uB2E4").onClick(async () => {
      button.setButtonText("\uC0AD\uC81C \uC911...");
      button.setDisabled(true);
      try {
        const success = await this.clearTTSCache();
        if (success) {
          new import_obsidian2.Notice("\u2705 TTS \uCE90\uC2DC\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
          this.updateCacheInfo(cacheInfoSetting);
        } else {
          new import_obsidian2.Notice("\u274C TTS \uCE90\uC2DC \uC0AD\uC81C\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
        }
      } catch (error) {
        console.error("TTS \uCE90\uC2DC \uC0AD\uC81C \uC624\uB958:", error);
        new import_obsidian2.Notice("\u274C TTS \uCE90\uC2DC \uC0AD\uC81C \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
      } finally {
        button.setButtonText("\uCE90\uC2DC \uC0AD\uC81C");
        button.setDisabled(false);
      }
    })).addButton((button) => button.setButtonText("\uC0C8\uB85C\uACE0\uCE68").setTooltip("\uCE90\uC2DC \uC815\uBCF4\uB97C \uC0C8\uB85C\uACE0\uCE68\uD569\uB2C8\uB2E4").onClick(async () => {
      this.updateCacheInfo(cacheInfoSetting);
      new import_obsidian2.Notice("\uCE90\uC2DC \uC815\uBCF4\uAC00 \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
    }));
  }
  async updateCacheInfo(setting) {
    try {
      if (this.plugin.ttsService && "getCacheInfo" in this.plugin.ttsService) {
        const cacheInfo = await this.plugin.ttsService.getCacheInfo();
        let detailedInfo = "";
        if (cacheInfo.totalFiles === 0) {
          detailedInfo = "\uCE90\uC2DC\uB41C \uD30C\uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.";
        } else {
          detailedInfo = `\uD30C\uC77C \uAC1C\uC218: ${cacheInfo.totalFiles}\uAC1C | \uCD1D \uC6A9\uB7C9: ${cacheInfo.formattedSize}`;
          if (cacheInfo.totalFiles > 0 && cacheInfo.totalSize > 0) {
            const avgSize = cacheInfo.totalSize / cacheInfo.totalFiles;
            const avgFormatted = this.formatFileSize(avgSize);
            detailedInfo += ` | \uD3C9\uADE0 \uD06C\uAE30: ${avgFormatted}`;
          }
        }
        const cacheFolder = `${this.plugin.settings.vocabularyFolderPath}/cache/tts`;
        setting.setDesc(`\uCE90\uC2DC \uD604\uD669 (${cacheFolder}) - ${detailedInfo}`);
      } else {
        setting.setDesc("\uCE90\uC2DC \uD604\uD669 - TTS \uCE90\uC2DC \uC11C\uBE44\uC2A4\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
    } catch (error) {
      console.error("\uCE90\uC2DC \uC815\uBCF4 \uC5C5\uB370\uC774\uD2B8 \uC624\uB958:", error);
      setting.setDesc("\uCE90\uC2DC \uD604\uD669 - \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  async clearTTSCache() {
    try {
      if (this.plugin.ttsService && "clearCache" in this.plugin.ttsService) {
        return await this.plugin.ttsService.clearCache();
      }
      return false;
    } catch (error) {
      console.error("TTS \uCE90\uC2DC \uC0AD\uC81C \uC624\uB958:", error);
      return false;
    }
  }
};

// src/features/vocabulary-learning/ui/VocabularyModal.ts
var import_obsidian6 = require("obsidian");

// src/infrastructure/tts/ChatterboxTTSService.ts
var import_obsidian3 = require("obsidian");

// src/shared/AudioManager.ts
var AudioManager = class _AudioManager {
  constructor() {
    this.activeAudioElements = /* @__PURE__ */ new Set();
    this.audioPool = [];
    this.maxPoolSize = 10;
  }
  static getInstance() {
    if (!_AudioManager.instance) {
      _AudioManager.instance = new _AudioManager();
    }
    return _AudioManager.instance;
  }
  // 오디오 요소 생성 및 관리
  createAudio(src) {
    let audio;
    const availableAudio = this.audioPool.find((a) => a.ended || a.paused);
    if (availableAudio) {
      audio = availableAudio;
      audio.src = src;
      audio.currentTime = 0;
    } else {
      audio = new Audio(src);
      this.setupAudioElement(audio);
    }
    this.activeAudioElements.add(audio);
    return audio;
  }
  // 오디오 요소 설정
  setupAudioElement(audio) {
    const cleanup = () => {
      this.releaseAudio(audio);
    };
    audio.addEventListener("ended", cleanup, { once: true });
    audio.addEventListener("error", cleanup, { once: true });
    setTimeout(() => {
      if (this.activeAudioElements.has(audio)) {
        this.releaseAudio(audio);
      }
    }, 3e4);
  }
  // 오디오 재생 (안전한 래퍼)
  async playAudio(src) {
    const audio = this.createAudio(src);
    try {
      await audio.play();
    } catch (error) {
      this.releaseAudio(audio);
      throw error;
    }
  }
  // 오디오 요소 해제
  releaseAudio(audio) {
    if (!this.activeAudioElements.has(audio))
      return;
    if (!audio.paused) {
      audio.pause();
    }
    this.activeAudioElements.delete(audio);
    if (this.audioPool.length < this.maxPoolSize) {
      audio.removeAttribute("src");
      audio.load();
      this.audioPool.push(audio);
    } else {
      this.disposeAudio(audio);
    }
  }
  // 오디오 요소 완전 정리
  disposeAudio(audio) {
    var _a;
    audio.pause();
    audio.removeAttribute("src");
    audio.load();
    const newAudio = audio.cloneNode();
    (_a = audio.parentNode) == null ? void 0 : _a.replaceChild(newAudio, audio);
  }
  // 모든 활성 오디오 정지
  stopAllAudio() {
    this.activeAudioElements.forEach((audio) => {
      if (!audio.paused) {
        audio.pause();
      }
    });
  }
  // 모든 리소스 정리
  cleanup() {
    this.activeAudioElements.forEach((audio) => {
      this.disposeAudio(audio);
    });
    this.activeAudioElements.clear();
    this.audioPool.forEach((audio) => {
      this.disposeAudio(audio);
    });
    this.audioPool.clear();
  }
  // 현재 상태 정보
  getStatus() {
    return {
      active: this.activeAudioElements.size,
      pooled: this.audioPool.length
    };
  }
};
var NetworkResourceManager = class _NetworkResourceManager {
  constructor() {
    this.abortControllers = /* @__PURE__ */ new Set();
    this.activeRequests = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    if (!_NetworkResourceManager.instance) {
      _NetworkResourceManager.instance = new _NetworkResourceManager();
    }
    return _NetworkResourceManager.instance;
  }
  // 네트워크 요청 생성 (자동 정리 포함)
  createRequest(identifier) {
    const controller = new AbortController();
    this.abortControllers.add(controller);
    if (identifier) {
      const existingController = this.activeRequests.get(identifier);
      if (existingController) {
        existingController.abort();
        this.abortControllers.delete(existingController);
      }
      this.activeRequests.set(identifier, controller);
    }
    setTimeout(() => {
      if (this.abortControllers.has(controller)) {
        controller.abort();
        this.cleanup(controller, identifier);
      }
    }, 6e4);
    return controller;
  }
  // 요청 완료 시 정리
  completeRequest(controller, identifier) {
    this.cleanup(controller, identifier);
  }
  // 특정 요청 취소
  cancelRequest(identifier) {
    const controller = this.activeRequests.get(identifier);
    if (controller) {
      controller.abort();
      this.cleanup(controller, identifier);
    }
  }
  // 내부 정리 로직
  cleanup(controller, identifier) {
    this.abortControllers.delete(controller);
    if (identifier) {
      this.activeRequests.delete(identifier);
    }
  }
  // 모든 활성 요청 취소
  cancelAllRequests() {
    this.abortControllers.forEach((controller) => {
      controller.abort();
    });
    this.abortControllers.clear();
    this.activeRequests.clear();
  }
  // Fetch 래퍼 (자동 정리 포함)
  async fetch(url, options = {}, identifier, timeout = 3e4) {
    const controller = this.createRequest(identifier);
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, timeout);
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      this.completeRequest(controller, identifier);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      this.cleanup(controller, identifier);
      throw error;
    }
  }
  // 현재 상태 정보
  getStatus() {
    return {
      active: this.abortControllers.size,
      identified: this.activeRequests.size
    };
  }
};

// src/infrastructure/tts/ChatterboxTTSService.ts
var ChatterboxTTSService = class {
  constructor(settings) {
    this.audioElement = null;
    this.currentAudioContext = null;
    this.settings = {
      enabled: settings.enabled || false,
      apiUrl: settings.apiUrl || "http://localhost:4123",
      voice: settings.voice || "alloy",
      response_format: settings.response_format || "wav",
      speed: settings.speed || 1,
      exaggeration: settings.exaggeration || 0.25,
      cfgWeight: settings.cfgWeight || 1,
      temperature: settings.temperature || 0.05,
      streaming_chunk_size: settings.streaming_chunk_size || 50,
      streaming_strategy: settings.streaming_strategy || "string",
      streaming_buffer_size: settings.streaming_buffer_size || 1,
      streaming_quality: settings.streaming_quality || "string",
      autoPlay: settings.autoPlay || false
    };
    this.audioManager = AudioManager.getInstance();
    this.networkManager = NetworkResourceManager.getInstance();
  }
  async speakText(text) {
    if (!this.settings.enabled) {
      new import_obsidian3.Notice("TTS \uAE30\uB2A5\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!text || text.trim().length === 0) {
      console.warn("TTS: \uBE48 \uD14D\uC2A4\uD2B8\uC785\uB2C8\uB2E4.");
      return;
    }
    try {
      this.stopSpeaking();
      const audioBlob = await this.callChatterboxAPI(text);
      await this.playAudioBlob(audioBlob);
    } catch (error) {
      console.error("Chatterbox TTS \uC624\uB958:", error);
      new import_obsidian3.Notice("TTS \uC74C\uC131 \uC0DD\uC131\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. Chatterbox TTS \uC11C\uBC84\uAC00 \uC2E4\uD589 \uC911\uC778\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
    }
  }
  async speakWord(word) {
    if (!word || word.trim().length === 0) {
      console.warn("TTS: \uBE48 \uB2E8\uC5B4\uC785\uB2C8\uB2E4.");
      return;
    }
    await this.speakText(word);
  }
  async speakExample(example, word) {
    if (!example || example.trim().length === 0) {
      console.warn("TTS: \uBE48 \uC608\uBB38\uC785\uB2C8\uB2E4.");
      return;
    }
    await this.speakText(example);
  }
  async callChatterboxAPI(text) {
    const truncatedText = text.length > 3e3 ? text.substring(0, 3e3) : text;
    const requestBody = {
      input: truncatedText,
      voice: this.settings.voice,
      response_format: this.settings.response_format,
      speed: this.settings.speed,
      exaggeration: this.settings.exaggeration,
      cfg_weight: this.settings.cfgWeight,
      temperature: this.settings.temperature,
      streaming_chunk_size: this.settings.streaming_chunk_size,
      streaming_strategy: this.settings.streaming_strategy,
      streaming_buffer_size: this.settings.streaming_buffer_size,
      streaming_quality: this.settings.streaming_quality
    };
    const response = await fetch(`${this.settings.apiUrl}/v1/audio/speech`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`Chatterbox TTS API \uC624\uB958: ${response.status} ${response.statusText}`);
    }
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("audio")) {
      throw new Error(`\uC608\uC0C1\uD558\uC9C0 \uBABB\uD55C \uC751\uB2F5 \uD615\uC2DD: ${contentType}`);
    }
    return await response.blob();
  }
  async playAudioBlob(audioBlob) {
    return new Promise((resolve, reject) => {
      try {
        if (this.audioElement) {
          this.audioElement.pause();
          this.audioElement.src = "";
        }
        this.audioElement = new Audio();
        const audioUrl = URL.createObjectURL(audioBlob);
        this.audioElement.src = audioUrl;
        this.audioElement.onended = () => {
          URL.revokeObjectURL(audioUrl);
          resolve();
        };
        this.audioElement.onerror = () => {
          URL.revokeObjectURL(audioUrl);
          reject(new Error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."));
        };
        this.audioElement.onloadeddata = () => {
          if (this.audioElement) {
            this.audioElement.play().catch((error) => {
              console.error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC2E4\uD328:", error);
              URL.revokeObjectURL(audioUrl);
              reject(error);
            });
          }
        };
        this.audioElement.load();
      } catch (error) {
        reject(error);
      }
    });
  }
  stopSpeaking() {
    if (this.audioElement) {
      this.audioElement.pause();
      this.audioElement.currentTime = 0;
      if (this.audioElement.src && this.audioElement.src.startsWith("blob:")) {
        URL.revokeObjectURL(this.audioElement.src);
      }
      this.audioElement.src = "";
    }
    if (this.currentAudioContext) {
      this.currentAudioContext.close().catch(console.error);
      this.currentAudioContext = null;
    }
  }
  isPaused() {
    return !this.audioElement || this.audioElement.paused;
  }
  resume() {
    if (this.audioElement && this.audioElement.paused) {
      this.audioElement.play().catch((error) => {
        console.error("\uC624\uB514\uC624 \uC7AC\uAC1C \uC2E4\uD328:", error);
        new import_obsidian3.Notice("\uC624\uB514\uC624 \uC7AC\uAC1C\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
      });
    }
  }
  pause() {
    if (this.audioElement && !this.audioElement.paused) {
      this.audioElement.pause();
    }
  }
  // 설정 업데이트
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
  }
  // 연결 테스트
  async testConnection() {
    try {
      const testText = "Hello, this is a test.";
      await this.callChatterboxAPI(testText);
      return true;
    } catch (error) {
      console.error("Chatterbox TTS \uC5F0\uACB0 \uD14C\uC2A4\uD2B8 \uC2E4\uD328:", error);
      return false;
    }
  }
  // 사용 가능한 음성 목록 (Chatterbox는 custom voice 지원)
  getAvailableVoices() {
    return [
      "alloy",
      "echo",
      "fable",
      "onyx",
      "nova",
      "shimmer",
      "custom"
      // 사용자 정의 음성
    ];
  }
  // 현재 설정 정보 반환
  getSettings() {
    return { ...this.settings };
  }
  // 캐시 관리 메서드들 (Chatterbox는 캐시를 지원하지 않으므로 더미 구현)
  async getCacheInfo() {
    return {
      totalFiles: 0,
      totalSize: 0,
      formattedSize: "0 B"
    };
  }
  async clearCache() {
    return true;
  }
  updateCacheFolder(vocabularyFolderPath) {
  }
  // 리소스 정리
  destroy() {
    this.stopSpeaking();
    this.audioElement = null;
    this.currentAudioContext = null;
  }
};

// src/infrastructure/tts/GoogleCloudTTSService.ts
var import_obsidian5 = require("obsidian");

// src/infrastructure/tts/TTSCacheManager.ts
var import_obsidian4 = require("obsidian");
var TTSCacheManager = class {
  constructor(app) {
    this.cacheFolder = "Vocabulary/cache/tts";
    this.app = app;
    this.initializeCacheFolder();
  }
  async initializeCacheFolder() {
    try {
      const folder = this.app.vault.getAbstractFileByPath(this.cacheFolder);
      if (folder instanceof import_obsidian4.TFolder) {
        return;
      }
      await this.app.vault.createFolder(this.cacheFolder);
    } catch (error) {
      if (error instanceof Error) {
        const errorMessage = error.message.toLowerCase();
        if (!errorMessage.includes("already exists") && !errorMessage.includes("folder already exists") && !errorMessage.includes("already present")) {
          console.warn("TTS \uCE90\uC2DC \uD3F4\uB354 \uC0DD\uC131 \uC2E4\uD328:", error);
        }
      }
    }
  }
  generateCacheKey(text, settings, word) {
    const keyData = {
      text: text.trim().toLowerCase(),
      languageCode: settings.languageCode,
      voice: settings.voice,
      speakingRate: settings.speakingRate,
      pitch: settings.pitch
    };
    const keyString = JSON.stringify(keyData);
    const hash = this.simpleHash(keyString);
    const cleanText = this.extractWordForFilename(text, word);
    return `${cleanText}_${hash}.mp3`;
  }
  extractWordForFilename(text, word) {
    let cleanText = text.trim().toLowerCase();
    const isLongText = cleanText.length > 50 || cleanText.includes(".") || cleanText.includes(",");
    if (isLongText && word) {
      const cleanWord = this.sanitizeForFilename(word);
      const words = cleanText.split(/[\s\.,!?;:]+/).filter((w) => w.length > 0);
      const examplePart = words.slice(0, 3).join("-");
      const cleanExample = this.sanitizeForFilename(examplePart);
      cleanText = `${cleanWord}_${cleanExample}`;
    } else if (isLongText) {
      const words = cleanText.split(/[\s\.,!?;:]+/).filter((w) => w.length > 0);
      const significantWords = words.slice(0, 3).join("_");
      cleanText = significantWords;
    } else {
      const firstWord = cleanText.split(/[\s\.,!?;:]+/)[0];
      cleanText = firstWord;
    }
    cleanText = this.sanitizeForFilename(cleanText);
    if (cleanText.length > 50) {
      cleanText = cleanText.substring(0, 50);
      cleanText = cleanText.replace(/[-_]+$/, "");
    }
    if (cleanText.length === 0) {
      cleanText = "tts";
    }
    return cleanText;
  }
  sanitizeForFilename(text) {
    let cleaned = text.replace(/[<>:"/\\|?*]/g, "");
    cleaned = cleaned.replace(/[^a-z0-9\-_]/g, "");
    cleaned = cleaned.replace(/[-_]+/g, "_");
    cleaned = cleaned.replace(/^_+|_+$/g, "");
    return cleaned;
  }
  simpleHash(str) {
    let hash = 0;
    if (str.length === 0)
      return hash.toString();
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  getCacheFilePath(cacheKey) {
    return (0, import_obsidian4.normalizePath)(`${this.cacheFolder}/${cacheKey}`);
  }
  async getCachedAudio(text, settings, word) {
    try {
      const cacheKey = this.generateCacheKey(text, settings, word);
      const filePath = this.getCacheFilePath(cacheKey);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian4.TFile) {
        const arrayBuffer = await this.app.vault.readBinary(file);
        console.log(`TTS \uCE90\uC2DC \uD788\uD2B8: "${text.substring(0, 50)}${text.length > 50 ? "..." : ""}" \u2192 ${cacheKey}`);
        return arrayBuffer;
      }
      return null;
    } catch (error) {
      console.warn("TTS \uCE90\uC2DC \uB85C\uB4DC \uC2E4\uD328:", error);
      return null;
    }
  }
  async setCachedAudio(text, settings, base64Audio, word) {
    try {
      await this.initializeCacheFolder();
      const cacheKey = this.generateCacheKey(text, settings, word);
      const filePath = this.getCacheFilePath(cacheKey);
      const binaryString = atob(base64Audio);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian4.TFile) {
        await this.app.vault.modifyBinary(existingFile, bytes.buffer);
      } else {
        await this.app.vault.createBinary(filePath, bytes.buffer);
      }
      console.log(`TTS \uCE90\uC2DC \uC800\uC7A5: "${text.substring(0, 50)}${text.length > 50 ? "..." : ""}" \u2192 ${cacheKey}`);
    } catch (error) {
      console.error("TTS \uCE90\uC2DC \uC800\uC7A5 \uC2E4\uD328:", error);
    }
  }
  async getCacheInfo() {
    try {
      const folder = this.app.vault.getAbstractFileByPath(this.cacheFolder);
      if (!(folder instanceof import_obsidian4.TFolder)) {
        return {
          totalFiles: 0,
          totalSize: 0,
          formattedSize: "0 B"
        };
      }
      let totalFiles = 0;
      let totalSize = 0;
      for (const file of folder.children) {
        if (file instanceof import_obsidian4.TFile && file.extension === "mp3") {
          totalFiles++;
          totalSize += file.stat.size;
        }
      }
      return {
        totalFiles,
        totalSize,
        formattedSize: this.formatFileSize(totalSize)
      };
    } catch (error) {
      console.error("TTS \uCE90\uC2DC \uC815\uBCF4 \uC870\uD68C \uC2E4\uD328:", error);
      return {
        totalFiles: 0,
        totalSize: 0,
        formattedSize: "0 B"
      };
    }
  }
  async clearCache() {
    try {
      const folder = this.app.vault.getAbstractFileByPath(this.cacheFolder);
      if (!(folder instanceof import_obsidian4.TFolder)) {
        return true;
      }
      const filesToDelete = folder.children.filter(
        (file) => file instanceof import_obsidian4.TFile && file.extension === "mp3"
      );
      for (const file of filesToDelete) {
        await this.app.fileManager.trashFile(file);
      }
      console.log(`TTS \uCE90\uC2DC \uC0AD\uC81C \uC644\uB8CC: ${filesToDelete.length}\uAC1C \uD30C\uC77C`);
      return true;
    } catch (error) {
      console.error("TTS \uCE90\uC2DC \uC0AD\uC81C \uC2E4\uD328:", error);
      return false;
    }
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  // 캐시 폴더 경로 업데이트
  updateCacheFolder(vocabularyFolderPath) {
    this.cacheFolder = `${vocabularyFolderPath}/cache/tts`;
    this.initializeCacheFolder();
  }
  // 캐시 통계 (개발/디버깅용)
  async getCacheStats() {
    return {
      hitCount: 0,
      missCount: 0,
      hitRate: 0
    };
  }
};

// src/infrastructure/tts/GoogleCloudTTSService.ts
var GoogleCloudTTSService = class {
  constructor(app, settings) {
    this.settings = {
      enabled: (settings == null ? void 0 : settings.enabled) || false,
      apiKey: (settings == null ? void 0 : settings.apiKey) || "",
      voice: (settings == null ? void 0 : settings.voice) || "en-US-Journey-F",
      languageCode: (settings == null ? void 0 : settings.languageCode) || "en-US",
      speakingRate: (settings == null ? void 0 : settings.speakingRate) || 1,
      pitch: (settings == null ? void 0 : settings.pitch) || 0,
      autoPlay: (settings == null ? void 0 : settings.autoPlay) || false,
      cacheEnabled: (settings == null ? void 0 : settings.cacheEnabled) !== false
    };
    this.audioManager = AudioManager.getInstance();
    this.networkManager = NetworkResourceManager.getInstance();
    this.cacheManager = new TTSCacheManager(app);
  }
  async speakText(text, word) {
    if (!this.settings.enabled) {
      new import_obsidian5.Notice("TTS \uAE30\uB2A5\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!this.settings.apiKey) {
      new import_obsidian5.Notice("Google Cloud TTS API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!text || text.trim().length === 0) {
      console.warn("TTS: \uBE48 \uD14D\uC2A4\uD2B8\uC785\uB2C8\uB2E4.");
      return;
    }
    try {
      this.stopSpeaking();
      let audioData;
      if (this.settings.cacheEnabled) {
        const cacheSettings = {
          languageCode: this.settings.languageCode,
          voice: this.settings.voice,
          speakingRate: this.settings.speakingRate,
          pitch: this.settings.pitch
        };
        const cachedAudio = await this.cacheManager.getCachedAudio(text, cacheSettings, word);
        if (cachedAudio) {
          await this.playAudioBuffer(cachedAudio);
          return;
        }
      }
      audioData = await this.callGoogleCloudAPI(text);
      if (this.settings.cacheEnabled) {
        const cacheSettings = {
          languageCode: this.settings.languageCode,
          voice: this.settings.voice,
          speakingRate: this.settings.speakingRate,
          pitch: this.settings.pitch
        };
        await this.cacheManager.setCachedAudio(text, cacheSettings, audioData, word);
      }
      await this.playAudioData(audioData);
    } catch (error) {
      console.error("Google Cloud TTS \uC624\uB958:", error);
      new import_obsidian5.Notice("TTS \uC74C\uC131 \uC0DD\uC131\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. API \uD0A4\uC640 \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
    }
  }
  async speakWord(word) {
    if (!word || word.trim().length === 0) {
      console.warn("TTS: \uBE48 \uB2E8\uC5B4\uC785\uB2C8\uB2E4.");
      return;
    }
    await this.speakText(word);
  }
  async speakExample(example, word) {
    if (!example || example.trim().length === 0) {
      console.warn("TTS: \uBE48 \uC608\uBB38\uC785\uB2C8\uB2E4.");
      return;
    }
    await this.speakText(example, word);
  }
  async callGoogleCloudAPI(text) {
    const truncatedText = text.length > 5e3 ? text.substring(0, 5e3) : text;
    const requestBody = {
      input: {
        text: truncatedText
      },
      voice: {
        languageCode: this.settings.languageCode,
        name: this.settings.voice
      },
      audioConfig: {
        audioEncoding: "MP3",
        speakingRate: this.settings.speakingRate,
        pitch: this.settings.pitch
      }
    };
    const response = await this.networkManager.fetch(
      `https://texttospeech.googleapis.com/v1/text:synthesize?key=${this.settings.apiKey}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      },
      `google-tts-${Date.now()}`,
      // 고유 식별자
      1e4
      // 10초 타임아웃
    );
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const errorMessage = this.getDetailedErrorMessage(response.status, errorData);
      throw new Error(errorMessage);
    }
    const data = await response.json();
    return data.audioContent;
  }
  getDetailedErrorMessage(status, errorData) {
    var _a, _b, _c, _d;
    if (errorData == null ? void 0 : errorData.error) {
      const error = errorData.error;
      if (status === 403 && ((_a = error.details) == null ? void 0 : _a.some(
        (detail) => {
          var _a2;
          return detail.reason === "API_KEY_SERVICE_BLOCKED" || ((_a2 = detail["@type"]) == null ? void 0 : _a2.includes("ErrorInfo")) && detail.reason === "API_KEY_SERVICE_BLOCKED";
        }
      ))) {
        return "Google Cloud Text-to-Speech API\uAC00 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. Google Cloud Console\uC5D0\uC11C Text-to-Speech API\uB97C \uD65C\uC131\uD654\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 403) {
        if (((_b = error.message) == null ? void 0 : _b.includes("API key not valid")) || error.code === "INVALID_ARGUMENT") {
          return "Google Cloud API \uD0A4\uAC00 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. API \uD0A4\uB97C \uB2E4\uC2DC \uD655\uC778\uD574\uC8FC\uC138\uC694.";
        }
        if (((_c = error.message) == null ? void 0 : _c.includes("quota")) || ((_d = error.message) == null ? void 0 : _d.includes("QUOTA_EXCEEDED"))) {
          return "Google Cloud TTS API \uD560\uB2F9\uB7C9\uC774 \uCD08\uACFC\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uD560\uB2F9\uB7C9\uC744 \uD655\uC778\uD558\uAC70\uB098 \uC694\uAE08\uC81C\uB97C \uBCC0\uACBD\uD574\uC8FC\uC138\uC694.";
        }
        return "Google Cloud TTS API \uC811\uADFC\uC774 \uAC70\uBD80\uB418\uC5C8\uC2B5\uB2C8\uB2E4. API \uD0A4 \uAD8C\uD55C\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 401) {
        return "Google Cloud API \uD0A4 \uC778\uC99D\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. API \uD0A4\uAC00 \uC62C\uBC14\uB978\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 400) {
        return "Google Cloud TTS API \uC694\uCCAD\uC774 \uC798\uBABB\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC74C\uC131 \uC124\uC815\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
      }
      if (status === 503) {
        return "Google Cloud TTS \uC11C\uBE44\uC2A4\uAC00 \uC77C\uC2DC\uC801\uC73C\uB85C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.";
      }
      return `Google Cloud TTS API \uC624\uB958 (${status}): ${error.message || "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958"}`;
    }
    return `Google Cloud TTS API \uC624\uB958: ${status} \uC0C1\uD0DC \uCF54\uB4DC`;
  }
  async playAudioData(base64Audio) {
    return new Promise((resolve, reject) => {
      try {
        const audioBlob = this.base64ToBlob(base64Audio, "audio/mp3");
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = this.audioManager.createAudio(audioUrl);
        const cleanup = () => {
          URL.revokeObjectURL(audioUrl);
          this.audioManager.releaseAudio(audio);
        };
        audio.onended = () => {
          cleanup();
          resolve();
        };
        audio.onerror = () => {
          cleanup();
          reject(new Error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."));
        };
        audio.onloadeddata = () => {
          audio.play().catch((error) => {
            console.error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC2E4\uD328:", error);
            cleanup();
            reject(error);
          });
        };
        setTimeout(() => {
          if (!audio.ended && !audio.paused) {
            cleanup();
            reject(new Error("\uC624\uB514\uC624 \uC7AC\uC0DD \uC2DC\uAC04 \uCD08\uACFC"));
          }
        }, 3e4);
      } catch (error) {
        reject(error);
      }
    });
  }
  async playAudioBuffer(audioBuffer) {
    return new Promise((resolve, reject) => {
      try {
        const audioBlob = new Blob([audioBuffer], { type: "audio/mp3" });
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = this.audioManager.createAudio(audioUrl);
        const cleanup = () => {
          URL.revokeObjectURL(audioUrl);
          this.audioManager.releaseAudio(audio);
        };
        audio.onended = () => {
          cleanup();
          resolve();
        };
        audio.onerror = () => {
          cleanup();
          reject(new Error("\uCE90\uC2DC\uB41C \uC624\uB514\uC624 \uC7AC\uC0DD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."));
        };
        audio.onloadeddata = () => {
          audio.play().catch((error) => {
            console.error("\uCE90\uC2DC\uB41C \uC624\uB514\uC624 \uC7AC\uC0DD \uC2E4\uD328:", error);
            cleanup();
            reject(error);
          });
        };
        setTimeout(() => {
          if (!audio.ended && !audio.paused) {
            cleanup();
            reject(new Error("\uCE90\uC2DC\uB41C \uC624\uB514\uC624 \uC7AC\uC0DD \uC2DC\uAC04 \uCD08\uACFC"));
          }
        }, 3e4);
      } catch (error) {
        reject(error);
      }
    });
  }
  base64ToBlob(base64, mimeType) {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType });
  }
  stopSpeaking() {
    this.audioManager.stopAllAudio();
  }
  isPaused() {
    const status = this.audioManager.getStatus();
    return status.active === 0;
  }
  resume() {
    new import_obsidian5.Notice("\uC74C\uC131\uC744 \uB2E4\uC2DC \uC7AC\uC0DD\uD558\uB824\uBA74 \uBC84\uD2BC\uC744 \uB2E4\uC2DC \uD074\uB9AD\uD574\uC8FC\uC138\uC694.");
  }
  pause() {
    this.stopSpeaking();
  }
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
  }
  // 리소스 정리
  cleanup() {
    this.audioManager.cleanup();
    this.networkManager.cancelAllRequests();
  }
  async testConnection() {
    try {
      const testText = "Hello, this is a test.";
      await this.callGoogleCloudAPI(testText);
      return true;
    } catch (error) {
      console.error("Google Cloud TTS \uC5F0\uACB0 \uD14C\uC2A4\uD2B8 \uC2E4\uD328:", error);
      return false;
    }
  }
  getAvailableVoices() {
    return [
      "en-US-Journey-D",
      "en-US-Journey-F",
      "en-US-Journey-O",
      "en-US-Neural2-A",
      "en-US-Neural2-C",
      "en-US-Neural2-D",
      "en-US-Neural2-E",
      "en-US-Neural2-F",
      "en-US-Neural2-G",
      "en-US-Neural2-H",
      "en-US-Neural2-I",
      "en-US-Neural2-J",
      "en-US-Standard-A",
      "en-US-Standard-B",
      "en-US-Standard-C",
      "en-US-Standard-D",
      "en-US-Standard-E",
      "en-US-Standard-F",
      "en-US-Standard-G",
      "en-US-Standard-H",
      "en-US-Standard-I",
      "en-US-Standard-J",
      "en-GB-Neural2-A",
      "en-GB-Neural2-B",
      "en-GB-Neural2-C",
      "en-GB-Neural2-D",
      "en-GB-Neural2-F",
      "en-AU-Neural2-A",
      "en-AU-Neural2-B",
      "en-AU-Neural2-C",
      "en-AU-Neural2-D"
    ];
  }
  getSettings() {
    return { ...this.settings };
  }
  destroy() {
    this.stopSpeaking();
  }
  // 캐시 관리 메서드들
  async getCacheInfo() {
    return await this.cacheManager.getCacheInfo();
  }
  async clearCache() {
    return await this.cacheManager.clearCache();
  }
  updateCacheFolder(vocabularyFolderPath) {
    this.cacheManager.updateCacheFolder(vocabularyFolderPath);
  }
};

// src/infrastructure/tts/TTSService.ts
var TTSServiceFactory = class {
  static createTTSService(app, settings) {
    if (!settings || !settings.ttsEnabled) {
      return new NoOpTTSService();
    }
    if (settings.ttsProvider === "google-cloud") {
      const googleSettings = {
        enabled: settings.ttsEnabled,
        apiKey: decryptApiKey(settings.googleCloudTTSApiKey),
        voice: settings.ttsVoice,
        languageCode: settings.googleCloudTTSLanguageCode,
        speakingRate: settings.googleCloudTTSSpeakingRate,
        pitch: settings.googleCloudTTSPitch,
        autoPlay: settings.ttsAutoPlay,
        cacheEnabled: settings.ttsCacheEnabled
      };
      return new GoogleCloudTTSService(app, googleSettings);
    } else {
      const chatterboxSettings = {
        enabled: settings.ttsEnabled,
        apiUrl: settings.chatterboxApiUrl,
        voice: settings.ttsVoice,
        response_format: "wav",
        speed: 1,
        exaggeration: settings.chatterboxExaggeration,
        cfgWeight: settings.chatterboxCfgWeight,
        temperature: settings.chatterboxTemperature,
        streaming_chunk_size: 50,
        streaming_strategy: "string",
        streaming_buffer_size: 1,
        streaming_quality: "string",
        autoPlay: settings.ttsAutoPlay
      };
      return new ChatterboxTTSService(chatterboxSettings);
    }
  }
};
var NoOpTTSService = class {
  async speakText(text) {
  }
  async speakWord(word) {
  }
  async speakExample(example) {
  }
  stopSpeaking() {
  }
  isPaused() {
    return true;
  }
  resume() {
  }
  pause() {
  }
  async testConnection() {
    return false;
  }
  getAvailableVoices() {
    return [];
  }
  destroy() {
  }
  // 캐시 관리 메서드들 (No-Op 구현)
  async getCacheInfo() {
    return {
      totalFiles: 0,
      totalSize: 0,
      formattedSize: "0 B"
    };
  }
  async clearCache() {
    return true;
  }
  updateCacheFolder(vocabularyFolderPath) {
  }
};

// src/core/algorithms/SpacedRepetitionAlgorithm.ts
var QUALITY_SCORES = {
  ["hard" /* Hard */]: 1,
  ["good" /* Good */]: 2,
  ["easy" /* Easy */]: 3
};
var DEFAULT_SRS_SETTINGS = {
  // SM-2 Algorithm Settings
  initialEFactor: 2.5,
  // SM-2 표준 초기 E-Factor
  minimumEFactor: 1.3,
  // SM-2 표준 최소 E-Factor
  maximumInterval: 36525,
  // ~100년
  // Initial Review Intervals (첫 번째 성공적인 복습 후 간격)
  hardInterval: 1,
  // Hard: 1일 후
  goodInterval: 2,
  // Good: 2일 후
  easyInterval: 3,
  // Easy: 3일 후
  // Load Balancing Settings
  loadBalance: true,
  maxFuzzingDays: 3,
  // Legacy compatibility (will be converted)
  baseEase: 250,
  // 2.5 * 100
  easyBonus: 1.3,
  hardPenalty: 0.5,
  minimumEase: 130,
  // 1.3 * 100
  initialInterval: 1
};
var SpacedRepetitionAlgorithm = class {
  constructor(settings = DEFAULT_SRS_SETTINGS) {
    this.dueDateHistogram = /* @__PURE__ */ new Map();
    this.settings = settings;
  }
  /**
   * Calculate the next review schedule based on user response
   * Implements the SM-2 algorithm according to learning_algorithm.md specification
   */
  schedule(response, currentSchedule) {
    const now = /* @__PURE__ */ new Date();
    const q = QUALITY_SCORES[response];
    if (!currentSchedule) {
      currentSchedule = {
        dueDate: now.toISOString(),
        interval: 0,
        ease: Math.round(this.settings.initialEFactor * 100),
        // E-Factor를 100으로 곱해서 저장
        reviewCount: 0,
        lapseCount: 0,
        delayedDays: 0,
        repetition: 0
      };
    }
    let currentEFactor = currentSchedule.ease / 100;
    let newRepetition = currentSchedule.repetition;
    const delta = 0.1 - (3 - q) * (0.08 + (3 - q) * 0.02);
    let newEFactor = currentEFactor + delta;
    newEFactor = Math.max(this.settings.minimumEFactor, newEFactor);
    let newInterval;
    if (q < 2) {
      newInterval = this.settings.hardInterval;
    } else {
      if (currentSchedule.repetition === 0) {
        if (q === 2) {
          newInterval = this.settings.goodInterval;
        } else {
          newInterval = this.settings.easyInterval;
        }
      } else if (currentSchedule.repetition === 1) {
        newInterval = 6;
      } else {
        newInterval = Math.round(currentSchedule.interval * newEFactor);
      }
    }
    if (q >= 2) {
      newRepetition = currentSchedule.repetition + 1;
    } else {
      newRepetition = 0;
    }
    newInterval = Math.min(newInterval, this.settings.maximumInterval);
    newInterval = Math.max(1, newInterval);
    if (this.settings.loadBalance) {
      newInterval = this.applyLoadBalancing(newInterval);
    }
    const newDueDate = new Date(now.getTime() + newInterval * 24 * 60 * 60 * 1e3);
    this.updateDueDateHistogram(newDueDate.toDateString());
    return {
      interval: newInterval,
      ease: Math.round(newEFactor * 100),
      // E-Factor를 100으로 곱해서 반환
      dueDate: newDueDate.toISOString(),
      repetition: newRepetition
    };
  }
  /**
   * Apply load balancing to distribute reviews evenly across days
   * Based on the histogram-based approach from obsidian-spaced-repetition
   */
  applyLoadBalancing(interval) {
    if (!this.settings.loadBalance) {
      return interval;
    }
    let fuzzingRange;
    if (interval <= 21) {
      fuzzingRange = 1;
    } else if (interval <= 180) {
      fuzzingRange = Math.max(1, interval * 0.05);
    } else {
      fuzzingRange = Math.max(1, interval * 0.025);
    }
    fuzzingRange = Math.min(fuzzingRange, this.settings.maxFuzzingDays);
    const now = /* @__PURE__ */ new Date();
    let bestInterval = interval;
    let minReviews = Number.MAX_SAFE_INTEGER;
    for (let offset = -fuzzingRange; offset <= fuzzingRange; offset++) {
      const testInterval = interval + offset;
      if (testInterval < 1)
        continue;
      const testDate = new Date(now.getTime() + testInterval * 24 * 60 * 60 * 1e3);
      const dateString = testDate.toDateString();
      const reviewCount = this.dueDateHistogram.get(dateString) || 0;
      if (reviewCount < minReviews) {
        minReviews = reviewCount;
        bestInterval = testInterval;
      }
    }
    return bestInterval;
  }
  /**
   * Update the due date histogram for load balancing
   */
  updateDueDateHistogram(dateString) {
    const current = this.dueDateHistogram.get(dateString) || 0;
    this.dueDateHistogram.set(dateString, current + 1);
  }
  /**
   * Get cards that are due for review
   */
  static getCardsForReview(cards) {
    const now = /* @__PURE__ */ new Date();
    return cards.filter((card) => {
      if (!card.scheduleInfo) {
        return true;
      }
      const dueDate = new Date(card.scheduleInfo.dueDate);
      return dueDate <= now;
    });
  }
  /**
   * Calculate the number of cards due in the next N days
   */
  static getCardsDueInDays(cards, days) {
    const now = /* @__PURE__ */ new Date();
    const futureDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1e3);
    return cards.filter((card) => {
      if (!card.scheduleInfo) {
        return true;
      }
      const dueDate = new Date(card.scheduleInfo.dueDate);
      return dueDate <= futureDate;
    }).length;
  }
  /**
   * Get learning statistics for a set of cards
   */
  static getStatistics(cards) {
    let newCards = 0;
    let learningCards = 0;
    let matureCards = 0;
    let totalEase = 0;
    let totalInterval = 0;
    let cardsWithSchedule = 0;
    cards.forEach((card) => {
      if (!card.scheduleInfo) {
        newCards++;
      } else {
        cardsWithSchedule++;
        totalEase += card.scheduleInfo.ease;
        totalInterval += card.scheduleInfo.interval;
        if (card.scheduleInfo.interval < 21) {
          learningCards++;
        } else {
          matureCards++;
        }
      }
    });
    return {
      total: cards.length,
      new: newCards,
      learning: learningCards,
      mature: matureCards,
      averageEase: cardsWithSchedule > 0 ? Math.round(totalEase / cardsWithSchedule) : 0,
      averageInterval: cardsWithSchedule > 0 ? Math.round(totalInterval / cardsWithSchedule) : 0
    };
  }
  /**
   * Update algorithm settings
   */
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Clear the due date histogram (useful for testing or reset)
   */
  clearHistogram() {
    this.dueDateHistogram.clear();
  }
};

// src/core/services/SpacedRepetitionService.ts
var SpacedRepetitionService = class {
  constructor(settings = {}) {
    this.currentSession = null;
    const srsSettings = { ...DEFAULT_SRS_SETTINGS, ...settings };
    this.algorithm = new SpacedRepetitionAlgorithm(srsSettings);
  }
  /**
   * Get cards that are due for review today
   */
  getCardsForReview(allCards) {
    return SpacedRepetitionAlgorithm.getCardsForReview(allCards);
  }
  /**
   * Get new cards (never reviewed)
   */
  getNewCards(allCards) {
    return allCards.filter((card) => !card.scheduleInfo || card.reviewCount === 0);
  }
  /**
   * Get learning cards (reviewed but not mature)
   */
  getLearningCards(allCards) {
    return allCards.filter(
      (card) => card.scheduleInfo && card.reviewCount > 0 && card.scheduleInfo.interval < 21
    );
  }
  /**
   * Get mature cards (interval >= 21 days)
   */
  getMatureCards(allCards) {
    return allCards.filter(
      (card) => card.scheduleInfo && card.scheduleInfo.interval >= 21
    );
  }
  /**
   * Start a new review session
   */
  startReviewSession(dueCards, maxCards) {
    const cardsToReview = maxCards ? dueCards.slice(0, maxCards) : dueCards;
    this.currentSession = {
      sessionId: this.generateSessionId(),
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      cardsReviewed: 0,
      totalCards: cardsToReview.length,
      completedCards: [],
      currentCard: cardsToReview[0],
      remainingCards: cardsToReview
      // Add remaining cards to track progress
    };
    return this.currentSession;
  }
  /**
   * Process a review response and get the next card
   */
  processReview(card, response) {
    var _a, _b, _c, _d;
    if (!this.currentSession) {
      throw new Error("No active review session");
    }
    const reviewResult = this.algorithm.schedule(response, card.scheduleInfo);
    const updatedCard = {
      ...card,
      reviewCount: (((_a = card.scheduleInfo) == null ? void 0 : _a.reviewCount) || 0) + 1,
      difficulty: response,
      lastReviewed: (/* @__PURE__ */ new Date()).toISOString(),
      scheduleInfo: {
        dueDate: reviewResult.dueDate,
        interval: reviewResult.interval,
        ease: reviewResult.ease,
        reviewCount: (((_b = card.scheduleInfo) == null ? void 0 : _b.reviewCount) || 0) + 1,
        lapseCount: (((_c = card.scheduleInfo) == null ? void 0 : _c.lapseCount) || 0) + (response === "hard" /* Hard */ ? 1 : 0),
        delayedDays: ((_d = card.scheduleInfo) == null ? void 0 : _d.delayedDays) || 0,
        repetition: reviewResult.repetition
      }
    };
    this.currentSession.cardsReviewed++;
    this.currentSession.completedCards.push(updatedCard);
    const remainingCards = this.currentSession.remainingCards || [];
    const nextCard = this.currentSession.cardsReviewed < remainingCards.length ? remainingCards[this.currentSession.cardsReviewed] : void 0;
    this.currentSession.currentCard = nextCard;
    const sessionComplete = !nextCard || this.currentSession.cardsReviewed >= this.currentSession.totalCards;
    if (sessionComplete) {
      this.endReviewSession();
    }
    return {
      updatedCard,
      nextCard,
      sessionComplete
    };
  }
  /**
   * End the current review session
   */
  endReviewSession() {
    const session = this.currentSession;
    this.currentSession = null;
    return session;
  }
  /**
   * Get current session info
   */
  getCurrentSession() {
    return this.currentSession;
  }
  /**
   * Calculate study statistics
   */
  calculateStatistics(allCards, studyHistory) {
    const now = /* @__PURE__ */ new Date();
    const today = now.toDateString();
    const overallStats = SpacedRepetitionAlgorithm.getStatistics(allCards);
    const todayStats = {
      newCards: 0,
      // Would track from session data
      reviewedCards: 0,
      // Would track from session data
      totalTime: 0
      // Would track from session timing
    };
    const streakStats = {
      currentDays: 0,
      // Would calculate from study history
      longestDays: 0,
      // Would calculate from study history
      lastStudyDate: null
    };
    return {
      today: todayStats,
      streak: streakStats,
      overall: overallStats
    };
  }
  /**
   * Get cards due in the next N days
   */
  getCardsDueInDays(allCards, days) {
    return SpacedRepetitionAlgorithm.getCardsDueInDays(allCards, days);
  }
  /**
   * Reset a card's schedule (for testing or manual intervention)
   */
  resetCardSchedule(card) {
    return {
      ...card,
      reviewCount: 0,
      lastReviewed: null,
      scheduleInfo: void 0
    };
  }
  /**
   * Manually set card difficulty (for bulk operations)
   */
  setCardDifficulty(card, difficulty) {
    var _a, _b;
    const reviewResult = this.algorithm.schedule(difficulty, card.scheduleInfo);
    return {
      ...card,
      difficulty,
      scheduleInfo: {
        dueDate: reviewResult.dueDate,
        interval: reviewResult.interval,
        ease: reviewResult.ease,
        reviewCount: (((_a = card.scheduleInfo) == null ? void 0 : _a.reviewCount) || 0) + 1,
        lapseCount: (((_b = card.scheduleInfo) == null ? void 0 : _b.lapseCount) || 0) + (difficulty === "hard" /* Hard */ ? 1 : 0),
        delayedDays: 0,
        repetition: reviewResult.repetition
      }
    };
  }
  /**
   * Update algorithm settings
   */
  updateSettings(settings) {
    this.algorithm.updateSettings(settings);
  }
  /**
   * Get current algorithm settings
   */
  getSettings() {
    return this.algorithm.getSettings();
  }
  /**
   * Generate a unique session ID
   */
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Get recommended daily study load
   */
  getRecommendedDailyCards(allCards) {
    const dueCards = this.getCardsForReview(allCards);
    const newCards = this.getNewCards(allCards);
    const maxNewCardsPerDay = 20;
    const maxReviewCardsPerDay = 100;
    const recommendedNew = Math.min(newCards.length, maxNewCardsPerDay);
    const recommendedReview = Math.min(dueCards.length - recommendedNew, maxReviewCardsPerDay);
    return {
      newCards: recommendedNew,
      reviewCards: recommendedReview,
      total: recommendedNew + recommendedReview
    };
  }
  /**
   * Export cards for data analysis or backup
   */
  exportScheduleData(allCards) {
    return allCards.map((card) => ({
      word: card.word,
      reviewCount: card.reviewCount,
      difficulty: card.difficulty,
      lastReviewed: card.lastReviewed,
      scheduleInfo: card.scheduleInfo,
      addedDate: card.addedDate
    }));
  }
  /**
   * Get the next review intervals for each difficulty level
   * Shows the exact SM-2 algorithm results with E-Factor information
   */
  getNextReviewIntervals(card) {
    const previewAlgorithm = new SpacedRepetitionAlgorithm(this.settings);
    const hardResult = previewAlgorithm.schedule("hard" /* Hard */, card.scheduleInfo);
    const goodResult = previewAlgorithm.schedule("good" /* Good */, card.scheduleInfo);
    const easyResult = previewAlgorithm.schedule("easy" /* Easy */, card.scheduleInfo);
    return {
      hard: {
        interval: hardResult.interval,
        displayText: this.formatInterval(hardResult.interval),
        eFactor: hardResult.ease / 100,
        // Convert back to E-Factor
        repetition: hardResult.repetition
      },
      good: {
        interval: goodResult.interval,
        displayText: this.formatInterval(goodResult.interval),
        eFactor: goodResult.ease / 100,
        repetition: goodResult.repetition
      },
      easy: {
        interval: easyResult.interval,
        displayText: this.formatInterval(easyResult.interval),
        eFactor: easyResult.ease / 100,
        repetition: easyResult.repetition
      }
    };
  }
  /**
   * Format interval as human-readable text
   */
  formatInterval(days) {
    if (days < 1) {
      return "today";
    } else if (days === 1) {
      return "1 day";
    } else if (days < 30) {
      return `${days} day${days > 1 ? "s" : ""}`;
    } else if (days < 365) {
      const months = Math.round(days / 30 * 10) / 10;
      return `${months} month${months > 1 ? "s" : ""}`;
    } else {
      const years = Math.round(days / 365 * 10) / 10;
      return `${years} year${years > 1 ? "s" : ""}`;
    }
  }
  /**
   * Get detailed SM-2 algorithm statistics
   */
  getSM2Statistics(allCards) {
    const stats = {
      overview: { totalCards: 0, newCards: 0, learningCards: 0, matureCards: 0 },
      repetitions: { rep0: 0, rep1: 0, rep2: 0, rep3Plus: 0 },
      eFactors: { average: 0, distribution: [] },
      intervals: { average: 0, distribution: [] }
    };
    let totalEFactor = 0;
    let totalInterval = 0;
    let cardsWithSchedule = 0;
    const eFactorBuckets = /* @__PURE__ */ new Map();
    const intervalBuckets = /* @__PURE__ */ new Map();
    allCards.forEach((card) => {
      stats.overview.totalCards++;
      if (!card.scheduleInfo) {
        stats.overview.newCards++;
        stats.repetitions.rep0++;
      } else {
        cardsWithSchedule++;
        const repetition = card.scheduleInfo.repetition || 0;
        const eFactor = card.scheduleInfo.ease / 100;
        const interval = card.scheduleInfo.interval;
        totalEFactor += eFactor;
        totalInterval += interval;
        if (repetition === 1)
          stats.repetitions.rep1++;
        else if (repetition === 2)
          stats.repetitions.rep2++;
        else if (repetition >= 3)
          stats.repetitions.rep3Plus++;
        else
          stats.repetitions.rep0++;
        if (interval >= 21) {
          stats.overview.matureCards++;
        } else {
          stats.overview.learningCards++;
        }
        const eFactorRange = this.getEFactorRange(eFactor);
        eFactorBuckets.set(eFactorRange, (eFactorBuckets.get(eFactorRange) || 0) + 1);
        const intervalRange = this.getIntervalRange(interval);
        intervalBuckets.set(intervalRange, (intervalBuckets.get(intervalRange) || 0) + 1);
      }
    });
    stats.eFactors.average = cardsWithSchedule > 0 ? Math.round(totalEFactor / cardsWithSchedule * 100) / 100 : 0;
    stats.intervals.average = cardsWithSchedule > 0 ? Math.round(totalInterval / cardsWithSchedule) : 0;
    stats.eFactors.distribution = Array.from(eFactorBuckets.entries()).map(([range, count]) => ({ range, count })).sort((a, b) => parseFloat(a.range.split("-")[0]) - parseFloat(b.range.split("-")[0]));
    stats.intervals.distribution = Array.from(intervalBuckets.entries()).map(([range, count]) => ({ range, count })).sort((a, b) => this.compareIntervalRanges(a.range, b.range));
    return stats;
  }
  /**
   * Get E-Factor range for grouping
   */
  getEFactorRange(eFactor) {
    if (eFactor < 1.5)
      return "1.3-1.5";
    if (eFactor < 2)
      return "1.5-2.0";
    if (eFactor < 2.5)
      return "2.0-2.5";
    if (eFactor < 3)
      return "2.5-3.0";
    if (eFactor < 3.5)
      return "3.0-3.5";
    return "3.5+";
  }
  /**
   * Get interval range for grouping
   */
  getIntervalRange(interval) {
    if (interval === 1)
      return "1 day";
    if (interval <= 6)
      return "2-6 days";
    if (interval <= 20)
      return "7-20 days";
    if (interval <= 60)
      return "21-60 days";
    if (interval <= 180)
      return "2-6 months";
    if (interval <= 365)
      return "6-12 months";
    return "1+ years";
  }
  /**
   * Compare interval ranges for sorting
   */
  compareIntervalRanges(a, b) {
    const order = ["1 day", "2-6 days", "7-20 days", "21-60 days", "2-6 months", "6-12 months", "1+ years"];
    return order.indexOf(a) - order.indexOf(b);
  }
};

// src/features/vocabulary-learning/ui/VocabularyModal.ts
var VocabularyModal = class extends import_obsidian6.Modal {
  constructor(app, plugin) {
    super(app);
    this.currentCardIndex = 0;
    this.cards = [];
    this.showAnswer = false;
    this.keydownHandler = null;
    this.currentSession = null;
    this.plugin = plugin;
    this.ttsService = TTSServiceFactory.createTTSService(app, plugin.settings);
    this.spacedRepetitionService = new SpacedRepetitionService();
  }
  onOpen() {
    const allCards = this.plugin.databaseManager.getAllWords();
    this.cards = this.spacedRepetitionService.getCardsForReview(allCards);
    if (this.cards.length === 0) {
      this.showNoCardsForReview(allCards.length);
      return;
    }
    this.currentSession = this.spacedRepetitionService.startReviewSession(this.cards);
    this.shuffleCards();
    this.currentCardIndex = 0;
    this.showAnswer = false;
    this.showCard();
    this.keydownHandler = (e) => {
      if (!this.showAnswer) {
        if (e.code === "Space" || e.key === " ") {
          e.preventDefault();
          this.showAnswer = true;
          this.showCard();
        }
      } else {
        if (e.key === "1") {
          this.handleReview("hard");
        } else if (e.key === "2") {
          this.handleReview("good");
        } else if (e.key === "3") {
          this.handleReview("easy");
        }
      }
    };
    window.addEventListener("keydown", this.keydownHandler);
  }
  shuffleCards() {
    for (let i = this.cards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
    }
  }
  showNoWordsMessage() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-learning-modal");
    contentEl.style.setProperty("--review-modal-height", `${this.plugin.settings.reviewModalHeight}vh`);
    const noWordsEl = contentEl.createEl("div", { cls: "no-words-message" });
    noWordsEl.createEl("h2", { text: "\uD559\uC2B5\uD560 \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4" });
    noWordsEl.createEl("p", { text: "\uB2E8\uC5B4\uC7A5\uC5D0 \uB2E8\uC5B4\uB97C \uCD94\uAC00\uD55C \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694." });
    const closeButton = noWordsEl.createEl("button", { text: "\uB2EB\uAE30" });
    closeButton.addClass("close-button");
    closeButton.addEventListener("click", () => this.close());
  }
  showNoCardsForReview(totalCards) {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-learning-modal");
    contentEl.style.setProperty("--review-modal-height", `${this.plugin.settings.reviewModalHeight}vh`);
    const noReviewEl = contentEl.createEl("div", { cls: "no-review-message" });
    noReviewEl.createEl("h2", { text: "\u{1F389} \uC624\uB298\uC758 \uBCF5\uC2B5 \uC644\uB8CC!" });
    if (totalCards > 0) {
      const stats = this.spacedRepetitionService.calculateStatistics(this.plugin.databaseManager.getAllWords());
      noReviewEl.createEl("p", {
        text: `\uCD1D ${totalCards}\uAC1C\uC758 \uB2E8\uC5B4 \uC911 \uC624\uB298 \uBCF5\uC2B5\uD560 \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.`
      });
      const nextDueCards = this.spacedRepetitionService.getCardsDueInDays(
        this.plugin.databaseManager.getAllWords(),
        1
      );
      if (nextDueCards > 0) {
        noReviewEl.createEl("p", {
          text: `\uB0B4\uC77C \uBCF5\uC2B5 \uC608\uC815: ${nextDueCards}\uAC1C \uB2E8\uC5B4`
        });
      }
      const statsEl = noReviewEl.createEl("div", { cls: "study-stats" });
      statsEl.createEl("h3", { text: "\uD559\uC2B5 \uD604\uD669" });
      statsEl.createEl("p", { text: `\u2022 \uC0C8 \uB2E8\uC5B4: ${stats.overall.newCards}\uAC1C` });
      statsEl.createEl("p", { text: `\u2022 \uD559\uC2B5 \uC911: ${stats.overall.learningCards}\uAC1C` });
      statsEl.createEl("p", { text: `\u2022 \uC644\uB8CC: ${stats.overall.matureCards}\uAC1C` });
    } else {
      noReviewEl.createEl("p", { text: "\uB2E8\uC5B4\uC7A5\uC5D0 \uB2E8\uC5B4\uB97C \uCD94\uAC00\uD55C \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694." });
    }
    const closeButton = noReviewEl.createEl("button", { text: "\uB2EB\uAE30" });
    closeButton.addClass("close-button");
    closeButton.addEventListener("click", () => this.close());
  }
  showCard() {
    if (this.currentCardIndex >= this.cards.length) {
      this.showCompletionMessage();
      return;
    }
    const currentCard = this.cards[this.currentCardIndex];
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-learning-modal");
    contentEl.style.setProperty("--review-modal-height", `${this.plugin.settings.reviewModalHeight}vh`);
    const cardContainer = contentEl.createEl("div", { cls: "vocabulary-card" });
    const topInfoContainer = cardContainer.createEl("div", { cls: "card-top-info" });
    const currentBook = this.plugin.databaseManager.getCurrentBook();
    if (currentBook) {
      const bookInfoEl = topInfoContainer.createEl("div", { cls: "book-info-display" });
      bookInfoEl.createEl("span", {
        text: currentBook.name,
        cls: "current-book-name"
      });
    }
    const deleteButton = topInfoContainer.createEl("button", {
      text: "\uCE74\uB4DC \uC0AD\uC81C",
      cls: "card-delete-button"
    });
    deleteButton.addEventListener("click", () => this.handleDeleteCard());
    const progressEl = cardContainer.createEl("div", { cls: "progress-indicator" });
    progressEl.textContent = `${this.currentCardIndex + 1} / ${this.cards.length}`;
    const wordContainer = cardContainer.createEl("div", { cls: "word-container" });
    const wordEl = wordContainer.createEl("h1", { cls: "card-word" });
    if (currentCard.pronunciation && currentCard.pronunciation.trim()) {
      wordEl.textContent = currentCard.word;
      wordEl.appendText(" ");
      wordEl.createEl("span", {
        text: `[${currentCard.pronunciation}]`,
        cls: "pronunciation"
      });
    } else {
      wordEl.textContent = currentCard.word;
    }
    const wordPlayButton = wordContainer.createEl("button", {
      cls: "tts-play-button word-play-button",
      attr: { "aria-label": "\uB2E8\uC5B4 \uBC1C\uC74C \uB4E3\uAE30" }
    });
    wordPlayButton.textContent = "\u{1F50A}";
    wordPlayButton.addEventListener("click", () => {
      this.ttsService.speakWord(currentCard.word);
    });
    if (currentCard.similarWords && currentCard.similarWords.length > 0) {
      const similarSection = cardContainer.createEl("div", { cls: "similar-words-section" });
      const similarWordsText = similarSection.createEl("p", {
        cls: "similar-words-inline",
        text: `\uC720\uC0AC\uD55C \uB2E8\uC5B4\uB4E4: ${currentCard.similarWords.join(", ")}`
      });
    }
    if (currentCard.examples && currentCard.examples.length > 0) {
      const examplesSection = cardContainer.createEl("div", { cls: "examples-section" });
      examplesSection.createEl("h3", { text: "\uC608\uBB38\uB4E4:" });
      currentCard.examples.forEach((example, index) => {
        const exampleContainer = examplesSection.createEl("div", { cls: "example-container" });
        const exampleTextContainer = exampleContainer.createEl("div", { cls: "example-text-container" });
        const englishExample = exampleTextContainer.createEl("p", { text: example.english });
        englishExample.addClass("english-example");
        const examplePlayButton = exampleTextContainer.createEl("button", {
          cls: "tts-play-button example-play-button",
          attr: { "aria-label": "\uC608\uBB38 \uBC1C\uC74C \uB4E3\uAE30" }
        });
        examplePlayButton.textContent = "\u{1F50A}";
        examplePlayButton.addEventListener("click", () => {
          this.ttsService.speakExample(example.english, currentCard.word);
        });
        if (this.showAnswer && example.korean && example.korean.trim()) {
          const koreanExample = exampleContainer.createEl("p", { text: example.korean });
          koreanExample.addClass("korean-example");
        }
      });
    } else {
      const examplesSection = cardContainer.createEl("div", { cls: "examples-section" });
      examplesSection.createEl("h3", { text: "\uC608\uBB38\uB4E4:" });
      const exampleContainer = examplesSection.createEl("div", { cls: "example-container" });
      const exampleTextContainer = exampleContainer.createEl("div", { cls: "example-text-container" });
      const englishExample = exampleTextContainer.createEl("p", {
        text: `This is an example sentence with the word "${currentCard.word}".`
      });
      englishExample.addClass("english-example");
      const examplePlayButton = exampleTextContainer.createEl("button", {
        cls: "tts-play-button example-play-button",
        attr: { "aria-label": "\uC608\uBB38 \uBC1C\uC74C \uB4E3\uAE30" }
      });
      examplePlayButton.textContent = "\u{1F50A}";
      examplePlayButton.addEventListener("click", () => {
        this.ttsService.speakExample(`This is an example sentence with the word "${currentCard.word}".`, currentCard.word);
      });
      if (this.showAnswer) {
        const koreanExample = exampleContainer.createEl("p", {
          text: `"${currentCard.word}"\uB77C\uB294 \uB2E8\uC5B4\uAC00 \uD3EC\uD568\uB41C \uC608\uBB38\uC785\uB2C8\uB2E4.`
        });
        koreanExample.addClass("korean-example");
      }
    }
    if (!this.showAnswer) {
      const checkButton = cardContainer.createEl("button", { text: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30" });
      checkButton.addClass("check-answer-button");
      checkButton.addEventListener("click", () => {
        this.showAnswer = true;
        this.showCard();
      });
    } else {
      const answerSection = cardContainer.createEl("div", { cls: "answer-section" });
      answerSection.createEl("h3", { text: "\uB73B:" });
      const meaningsList = answerSection.createEl("ul", { cls: "meanings-list" });
      currentCard.meanings.forEach((meaning) => {
        meaningsList.createEl("li", { text: meaning });
      });
      this.createReviewButtons(cardContainer);
    }
  }
  createReviewButtons(container2) {
    const reviewSection = container2.createEl("div", { cls: "review-buttons-section" });
    const currentCard = this.cards[this.currentCardIndex];
    const intervals = this.spacedRepetitionService.getNextReviewIntervals(currentCard);
    const hardButton = reviewSection.createEl("button");
    hardButton.addClass("review-button", "hard-button");
    const hardContent = hardButton.createEl("div", { cls: "button-content" });
    hardContent.createEl("span", { text: "\uC5B4\uB824\uC6C0", cls: "button-label" });
    hardContent.createEl("span", { text: intervals.hard.displayText, cls: "button-interval" });
    hardButton.addEventListener("click", () => this.handleReview("hard"));
    const goodButton = reviewSection.createEl("button");
    goodButton.addClass("review-button", "good-button");
    const goodContent = goodButton.createEl("div", { cls: "button-content" });
    goodContent.createEl("span", { text: "\uC88B\uC74C", cls: "button-label" });
    goodContent.createEl("span", { text: intervals.good.displayText, cls: "button-interval" });
    goodButton.addEventListener("click", () => this.handleReview("good"));
    const easyButton = reviewSection.createEl("button");
    easyButton.addClass("review-button", "easy-button");
    const easyContent = easyButton.createEl("div", { cls: "button-content" });
    easyContent.createEl("span", { text: "\uC26C\uC6C0", cls: "button-label" });
    easyContent.createEl("span", { text: intervals.easy.displayText, cls: "button-interval" });
    easyButton.addEventListener("click", () => this.handleReview("easy"));
  }
  async handleReview(difficulty) {
    const currentCard = this.cards[this.currentCardIndex];
    const activeSession = this.spacedRepetitionService.getCurrentSession();
    if (!activeSession) {
      console.error("No active review session in SpacedRepetitionService");
      const remainingCards = this.cards.slice(this.currentCardIndex);
      if (remainingCards.length > 0) {
        this.currentSession = this.spacedRepetitionService.startReviewSession(remainingCards);
      } else {
        console.error("No remaining cards to review");
        return;
      }
    }
    const reviewResponse = difficulty;
    try {
      const result = this.spacedRepetitionService.processReview(currentCard, reviewResponse);
      await this.plugin.databaseManager.updateWordWithSchedule(
        result.updatedCard.word,
        difficulty,
        result.updatedCard.scheduleInfo
      );
      this.currentCardIndex++;
      this.showAnswer = false;
      this.showCard();
    } catch (error) {
      console.error("Error processing spaced repetition review:", error);
      await this.plugin.databaseManager.updateWord(currentCard.word, difficulty);
      this.currentCardIndex++;
      this.showAnswer = false;
      this.showCard();
    }
  }
  async handleDeleteCard() {
    const currentCard = this.cards[this.currentCardIndex];
    const confirmModal = new ConfirmModal(
      this.app,
      "\uB2E8\uC5B4 \uC0AD\uC81C",
      `"${currentCard.word}" \uB2E8\uC5B4\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?

\uC774 \uC791\uC5C5\uC740 \uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`,
      async () => {
        try {
          await this.plugin.databaseManager.removeWord(currentCard.word);
          this.cards.splice(this.currentCardIndex, 1);
          if (this.cards.length === 0) {
            this.showCompletionMessage();
            return;
          }
          if (this.currentCardIndex >= this.cards.length) {
            this.currentCardIndex = this.cards.length - 1;
          }
          this.showAnswer = false;
          this.showCard();
        } catch (error) {
          console.error("\uB2E8\uC5B4 \uC0AD\uC81C \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
          new import_obsidian6.Notice("\uB2E8\uC5B4 \uC0AD\uC81C \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
        }
      }
    );
    confirmModal.open();
  }
  showCompletionMessage() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-learning-modal");
    contentEl.style.setProperty("--review-modal-height", `${this.plugin.settings.reviewModalHeight}vh`);
    const completionEl = contentEl.createEl("div", { cls: "completion-message" });
    completionEl.createEl("h2", { text: "\uD559\uC2B5 \uC644\uB8CC!" });
    completionEl.createEl("p", { text: `\uC624\uB298 ${this.cards.length}\uAC1C\uC758 \uB2E8\uC5B4 \uD559\uC2B5\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4.` });
    const restartButton = completionEl.createEl("button", { text: "\uB2E4\uC2DC \uD559\uC2B5\uD558\uAE30" });
    restartButton.addClass("restart-button");
    restartButton.addEventListener("click", () => {
      this.onOpen();
    });
    const closeButton = completionEl.createEl("button", { text: "\uB2EB\uAE30" });
    closeButton.addClass("close-button");
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    if (this.keydownHandler) {
      window.removeEventListener("keydown", this.keydownHandler);
      this.keydownHandler = null;
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian6.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("h2", { text: this.title, cls: "modal-title" });
    contentEl.createEl("p", { text: this.message, cls: "modal-message" });
    const buttonSection = contentEl.createEl("div", { cls: "button-section" });
    const confirmButton = buttonSection.createEl("button", {
      text: "\uD655\uC778",
      cls: "confirm-button primary"
    });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    const cancelButton = buttonSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "cancel-button"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/features/book-management/ui/VocabularyManagerModal.ts
var import_obsidian9 = require("obsidian");

// src/infrastructure/external/WordService.ts
var WordService = class {
  constructor() {
    this.apiBaseUrl = "https://api.dictionaryapi.dev/api/v2/entries/en";
  }
  async getWordData(word) {
    try {
      return this.getSampleWordData(word);
    } catch (error) {
      console.error("\uB2E8\uC5B4 \uB370\uC774\uD130\uB97C \uAC00\uC838\uC624\uB294 \uC911 \uC624\uB958:", error);
      throw new Error("\uB2E8\uC5B4 \uB370\uC774\uD130\uB97C \uAC00\uC838\uC62C \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
  }
  getSampleWordData(word) {
    const sampleData = {
      "beautiful": {
        word: "beautiful",
        pronunciation: "/\u02C8bju\u02D0t\u026Af\u0259l/",
        meanings: ["\uC544\uB984\uB2E4\uC6B4", "\uC608\uC05C", "\uD6CC\uB96D\uD55C"],
        similarWords: ["pretty", "gorgeous", "stunning", "attractive"],
        examples: [
          {
            english: "She is a beautiful woman.",
            korean: "\uADF8\uB140\uB294 \uC544\uB984\uB2E4\uC6B4 \uC5EC\uC131\uC785\uB2C8\uB2E4."
          },
          {
            english: "The sunset was beautiful.",
            korean: "\uC77C\uBAB0\uC774 \uC544\uB984\uB2E4\uC6E0\uC2B5\uB2C8\uB2E4."
          },
          {
            english: "What a beautiful day!",
            korean: "\uC815\uB9D0 \uC544\uB984\uB2E4\uC6B4 \uD558\uB8E8\uB124\uC694!"
          }
        ]
      },
      "happy": {
        word: "happy",
        pronunciation: "/\u02C8h\xE6pi/",
        meanings: ["\uD589\uBCF5\uD55C", "\uAE30\uC05C", "\uC990\uAC70\uC6B4"],
        similarWords: ["joyful", "cheerful", "glad", "pleased"],
        examples: [
          {
            english: "I am happy to see you.",
            korean: "\uB2F9\uC2E0\uC744 \uB9CC\uB098\uC11C \uAE30\uC069\uB2C8\uB2E4."
          },
          {
            english: "She has a happy family.",
            korean: "\uADF8\uB140\uB294 \uD589\uBCF5\uD55C \uAC00\uC871\uC744 \uAC00\uC9C0\uACE0 \uC788\uC2B5\uB2C8\uB2E4."
          },
          {
            english: "Happy birthday!",
            korean: "\uC0DD\uC77C \uCD95\uD558\uD569\uB2C8\uB2E4!"
          }
        ]
      },
      "learn": {
        word: "learn",
        pronunciation: "/l\u025C\u02D0rn/",
        meanings: ["\uBC30\uC6B0\uB2E4", "\uD559\uC2B5\uD558\uB2E4", "\uC775\uD788\uB2E4"],
        similarWords: ["study", "acquire", "grasp", "understand"],
        examples: [
          {
            english: "I want to learn English.",
            korean: "\uC800\uB294 \uC601\uC5B4\uB97C \uBC30\uC6B0\uACE0 \uC2F6\uC2B5\uB2C8\uB2E4."
          },
          {
            english: "Children learn quickly.",
            korean: "\uC544\uC774\uB4E4\uC740 \uBE68\uB9AC \uBC30\uC6C1\uB2C8\uB2E4."
          },
          {
            english: "You can learn from your mistakes.",
            korean: "\uC2E4\uC218\uB85C\uBD80\uD130 \uBC30\uC6B8 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
          }
        ]
      }
    };
    if (sampleData[word.toLowerCase()]) {
      return sampleData[word.toLowerCase()];
    }
    return {
      word,
      pronunciation: "/pronunciation/",
      meanings: ["\uC758\uBBF8\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."],
      similarWords: [],
      examples: [
        {
          english: `This is an example sentence with the word "${word}".`,
          korean: `"${word}"\uB77C\uB294 \uB2E8\uC5B4\uAC00 \uD3EC\uD568\uB41C \uC608\uBB38\uC785\uB2C8\uB2E4.`
        }
      ]
    };
  }
  // 실제 API 호출을 위한 메서드 (향후 구현)
  async fetchFromAPI(word) {
    const response = await fetch(`${this.apiBaseUrl}/${word}`);
    if (!response.ok) {
      throw new Error(`API \uC694\uCCAD \uC2E4\uD328: ${response.status}`);
    }
    return await response.json();
  }
};

// src/features/book-management/ui/AddBookModal.ts
var import_obsidian7 = require("obsidian");
var AddBookModal = class extends import_obsidian7.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("add-book-modal");
    const titleEl = contentEl.createEl("h2", { text: "\uB2E8\uC5B4\uC7A5 \uCD94\uAC00", cls: "modal-title" });
    const descriptionEl = contentEl.createEl("p", {
      text: "\uC0C8\uB85C\uC6B4 \uB2E8\uC5B4\uC7A5\uC744 \uC0DD\uC131\uD569\uB2C8\uB2E4.",
      cls: "modal-description"
    });
    const formEl = contentEl.createEl("form", { cls: "book-form" });
    const nameSection = formEl.createEl("div", { cls: "form-section" });
    const nameLabel = nameSection.createEl("label", {
      text: "\uB2E8\uC5B4\uC7A5 \uC774\uB984 *",
      cls: "form-label"
    });
    const nameInput = nameSection.createEl("input", {
      type: "text",
      placeholder: "\uC608: TOEIC \uB2E8\uC5B4\uC7A5, \uC77C\uC0C1\uC0DD\uD65C \uB2E8\uC5B4\uC7A5",
      cls: "form-input"
    });
    nameInput.required = true;
    const descSection = formEl.createEl("div", { cls: "form-section" });
    const descLabel = descSection.createEl("label", {
      text: "\uC124\uBA85 (\uC120\uD0DD\uC0AC\uD56D)",
      cls: "form-label"
    });
    const descInput = descSection.createEl("textarea", {
      placeholder: "\uB2E8\uC5B4\uC7A5\uC5D0 \uB300\uD55C \uC124\uBA85\uC744 \uC785\uB825\uD558\uC138\uC694.",
      cls: "form-textarea"
    });
    descInput.rows = 3;
    const buttonSection = formEl.createEl("div", { cls: "button-section" });
    const createButton = buttonSection.createEl("button", {
      text: "\uB2E8\uC5B4\uC7A5 \uC0DD\uC131",
      cls: "create-button primary",
      type: "submit"
    });
    const cancelButton = buttonSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "cancel-button",
      type: "button"
    });
    cancelButton.addEventListener("click", () => this.close());
    formEl.addEventListener("submit", async (e) => {
      e.preventDefault();
      await this.createBook(nameInput.value.trim(), descInput.value.trim());
    });
    nameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        formEl.dispatchEvent(new Event("submit"));
      }
    });
    nameInput.focus();
  }
  async createBook(name, description) {
    if (!name.trim()) {
      new import_obsidian7.Notice("\uB2E8\uC5B4\uC7A5 \uC774\uB984\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    try {
      const existingBooks = this.plugin.databaseManager.getAllBooks();
      const isDuplicate = existingBooks.some(
        (book) => book.name && typeof book.name === "string" && book.name.toLowerCase() === name.toLowerCase()
      );
      if (isDuplicate) {
        new import_obsidian7.Notice("\uC774\uBBF8 \uC874\uC7AC\uD558\uB294 \uB2E8\uC5B4\uC7A5 \uC774\uB984\uC785\uB2C8\uB2E4.");
        return;
      }
      const newBook = await this.plugin.databaseManager.createBook(name, description);
      new import_obsidian7.Notice(`"${name}" \uB2E8\uC5B4\uC7A5\uC774 \uC131\uACF5\uC801\uC73C\uB85C \uC0DD\uC131\uB418\uC5C8\uC2B5\uB2C8\uB2E4!`);
      this.close();
      const event = new CustomEvent("bookCreated", { detail: newBook });
      document.dispatchEvent(event);
    } catch (error) {
      console.error("\uB2E8\uC5B4\uC7A5 \uC0DD\uC131 \uC2E4\uD328:", error);
      new import_obsidian7.Notice("\uB2E8\uC5B4\uC7A5 \uC0DD\uC131\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/features/word-management/ui/AddWordsModal.ts
var import_obsidian8 = require("obsidian");

// src/shared/validation.ts
function validateString(input, options = {}) {
  const {
    minLength = 0,
    maxLength = 1e3,
    allowEmpty = false,
    pattern,
    fieldName = "\uC785\uB825\uAC12"
  } = options;
  if (!input || input.trim().length === 0) {
    if (allowEmpty) {
      return { isValid: true, sanitized: "" };
    }
    return { isValid: false, error: `${fieldName}\uC740(\uB294) \uD544\uC218 \uC785\uB825\uAC12\uC785\uB2C8\uB2E4.` };
  }
  const trimmed = input.trim();
  if (trimmed.length < minLength) {
    return {
      isValid: false,
      error: `${fieldName}\uC740(\uB294) \uCD5C\uC18C ${minLength}\uC790 \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.`
    };
  }
  if (trimmed.length > maxLength) {
    return {
      isValid: false,
      error: `${fieldName}\uC740(\uB294) \uCD5C\uB300 ${maxLength}\uC790 \uC774\uD558\uC5EC\uC57C \uD569\uB2C8\uB2E4.`
    };
  }
  if (pattern && !pattern.test(trimmed)) {
    return {
      isValid: false,
      error: `${fieldName}\uC758 \uD615\uC2DD\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.`
    };
  }
  return { isValid: true, sanitized: trimmed };
}
function validateWord(word) {
  const validation = validateString(word, {
    minLength: 1,
    maxLength: 50,
    pattern: /^[a-zA-Z\s'-]+$/,
    fieldName: "\uB2E8\uC5B4"
  });
  if (!validation.isValid) {
    return validation;
  }
  const sanitized = validation.sanitized.replace(/[^\w\s'-]/g, "").replace(/\s+/g, " ");
  return { isValid: true, sanitized };
}
function sanitizeMarkdown(text) {
  if (!text)
    return "";
  return text.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<iframe[^>]*>[\s\S]*?<\/iframe>/gi, "").replace(/javascript:/gi, "").replace(/on\w+\s*=/gi, "").trim();
}
function validateBatch(items, validator) {
  const valid = [];
  const invalid = [];
  for (const item of items) {
    const result = validator(item);
    if (result.isValid) {
      valid.push(item);
    } else {
      invalid.push({ item, error: result.error || "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958" });
    }
  }
  return { valid, invalid };
}

// src/shared/CancellationToken.ts
var CancellationTokenSource = class {
  constructor() {
    this._isCancelled = false;
    this._callbacks = [];
  }
  get token() {
    return {
      get isCancelled() {
        return this._isCancelled;
      },
      throwIfCancelled: () => {
        if (this._isCancelled) {
          throw new CancellationError("Operation was cancelled");
        }
      },
      onCancelled: (callback) => {
        if (this._isCancelled) {
          callback();
        } else {
          this._callbacks.push(callback);
        }
      }
    };
  }
  cancel() {
    if (this._isCancelled)
      return;
    this._isCancelled = true;
    this._callbacks.forEach((callback) => {
      try {
        callback();
      } catch (error) {
        console.error("Error in cancellation callback:", error);
      }
    });
    this._callbacks.length = 0;
  }
  dispose() {
    this._callbacks.length = 0;
  }
};
var CancellationError = class extends Error {
  constructor(message = "Operation was cancelled") {
    super(message);
    this.name = "CancellationError";
  }
};
function delay(ms, cancellationToken) {
  return new Promise((resolve, reject) => {
    if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
      reject(new CancellationError());
      return;
    }
    const timeoutId = setTimeout(() => {
      resolve();
    }, ms);
    cancellationToken == null ? void 0 : cancellationToken.onCancelled(() => {
      clearTimeout(timeoutId);
      reject(new CancellationError());
    });
  });
}
async function withCancellation(promise, cancellationToken) {
  if (!cancellationToken) {
    return promise;
  }
  return new Promise((resolve, reject) => {
    if (cancellationToken.isCancelled) {
      reject(new CancellationError());
      return;
    }
    let isResolved = false;
    promise.then(
      (value) => {
        if (!isResolved) {
          isResolved = true;
          resolve(value);
        }
      },
      (error) => {
        if (!isResolved) {
          isResolved = true;
          reject(error);
        }
      }
    );
    cancellationToken.onCancelled(() => {
      if (!isResolved) {
        isResolved = true;
        reject(new CancellationError());
      }
    });
  });
}
async function processBatchWithCancellation(items, processor, options = {}) {
  const {
    batchSize = 10,
    delay: delayMs = 100,
    cancellationToken,
    onProgress
  } = options;
  const results = [];
  for (let i = 0; i < items.length; i += batchSize) {
    cancellationToken == null ? void 0 : cancellationToken.throwIfCancelled();
    const batch = items.slice(i, i + batchSize);
    const batchPromises = batch.map(
      (item, batchIndex) => processor(item, i + batchIndex)
    );
    try {
      const batchResults = await withCancellation(
        Promise.all(batchPromises),
        cancellationToken
      );
      results.push(...batchResults);
      onProgress == null ? void 0 : onProgress(Math.min(i + batchSize, items.length), items.length);
      if (i + batchSize < items.length && delayMs > 0) {
        await delay(delayMs, cancellationToken);
      }
    } catch (error) {
      if (error instanceof CancellationError) {
        throw error;
      }
      throw error;
    }
  }
  return results;
}

// src/features/word-management/ui/AddWordsModal.ts
var AddWordsModal = class extends import_obsidian8.Modal {
  constructor(app, plugin, selectedBookId) {
    super(app);
    this.isProcessing = false;
    this.cancellationTokenSource = null;
    this.plugin = plugin;
    this.wordService = new WordService();
    this.selectedBookId = selectedBookId || "default";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("add-words-modal");
    await this.plugin.databaseManager.loadAllBooks();
    const bookSelectSection = contentEl.createEl("div", { cls: "book-select-section" });
    const bookLabel = bookSelectSection.createEl("label", { text: "\uB2E8\uC5B4\uC7A5 \uC120\uD0DD", cls: "book-select-label" });
    const bookSelectContainer = bookSelectSection.createEl("div", { cls: "book-select-container" });
    this.bookSelect = bookSelectContainer.createEl("select", { cls: "book-select-dropdown" });
    const addBookButton = bookSelectContainer.createEl("button", {
      text: "\uB2E8\uC5B4\uC7A5 \uCD94\uAC00",
      cls: "add-book-button"
    });
    addBookButton.addEventListener("click", () => this.openAddBookModal());
    await this.updateBookSelect();
    this.bookSelect.addEventListener("change", (e) => {
      const selectedBookId = e.target.value;
      this.selectedBookId = selectedBookId;
      this.plugin.databaseManager.setCurrentBook(selectedBookId);
    });
    document.addEventListener("bookCreated", this.handleBookCreated.bind(this));
    const titleEl = contentEl.createEl("h2", { text: "\uB2E8\uC5B4 \uCD94\uAC00", cls: "modal-title" });
    const descriptionEl = contentEl.createEl("p", {
      text: "\uCD94\uAC00\uD560 \uC601\uB2E8\uC5B4\uB4E4\uC744 \uC785\uB825\uD558\uC138\uC694. \uAC01 \uB2E8\uC5B4\uB294 \uC0C8 \uC904\uB85C \uAD6C\uBD84\uB429\uB2C8\uB2E4.",
      cls: "modal-description"
    });
    const inputSection = contentEl.createEl("div", { cls: "input-section" });
    const textarea = inputSection.createEl("textarea", {
      placeholder: "beautiful\nhappy\nlearn\nstudy\nwork\n...",
      cls: "words-textarea"
    });
    textarea.setAttribute("rows", "10");
    const exampleBtn = inputSection.createEl("button", {
      text: "\uC608\uC2DC \uB2E8\uC5B4\uB4E4 \uBD88\uB7EC\uC624\uAE30",
      cls: "example-button"
    });
    exampleBtn.addEventListener("click", () => {
      textarea.value = "beautiful\nhappy\nlearn\nstudy\nwork\nimportant\nsuccess\nknowledge\nexperience\nfreedom";
    });
    const buttonSection = contentEl.createEl("div", { cls: "button-section" });
    const addButton = buttonSection.createEl("button", {
      text: "\uB2E8\uC5B4 \uCD94\uAC00",
      cls: "add-button primary"
    });
    addButton.addEventListener("click", () => this.addWords(textarea.value, this.selectedBookId));
    const cancelButton = buttonSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "cancel-button"
    });
    cancelButton.addEventListener("click", () => {
      if (this.isProcessing) {
        this.cancelOperation();
      } else {
        this.close();
      }
    });
    const progressSection = contentEl.createEl("div", { cls: "progress-section display-none" });
    const progressText = progressSection.createEl("p", {
      text: "\uB2E8\uC5B4\uB97C \uCD94\uAC00\uD558\uB294 \uC911...",
      cls: "progress-text"
    });
    const progressBar = progressSection.createEl("div", { cls: "progress-bar" });
    const progressFill = progressBar.createEl("div", { cls: "progress-fill" });
    const resultSection = contentEl.createEl("div", { cls: "result-section display-none" });
    textarea.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "Enter") {
        this.addWords(textarea.value, this.selectedBookId);
      }
    });
    textarea.focus();
  }
  async addWords(inputText, bookId) {
    var _a;
    if (this.isProcessing)
      return;
    const words = this.parseWords(inputText);
    if (words.length === 0) {
      new import_obsidian8.Notice("\uCD94\uAC00\uD560 \uB2E8\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    this.isProcessing = true;
    this.cancellationTokenSource = new CancellationTokenSource();
    this.showProgress(words.length);
    this.updateCancelButton(true);
    const results = {
      success: [],
      failed: [],
      alreadyExists: []
    };
    try {
      await processBatchWithCancellation(
        words,
        async (word, index) => {
          const existingWord = this.plugin.databaseManager.getWord(word);
          if (existingWord) {
            results.alreadyExists.push(word);
            return;
          }
          try {
            const wordData = await this.wordService.getWordData(word);
            const vocabularyCard = {
              ...wordData,
              reviewCount: 0,
              difficulty: "none",
              // 초기 난이도 (학습 전)
              lastReviewed: null,
              addedDate: (/* @__PURE__ */ new Date()).toISOString(),
              bookId
            };
            await this.plugin.databaseManager.addWord(vocabularyCard);
            results.success.push(word);
          } catch (error) {
            results.failed.push(word);
            console.error(`\uB2E8\uC5B4 "${word}" \uCD94\uAC00 \uC2E4\uD328:`, error);
          }
        },
        {
          batchSize: getConfigValue(CONFIG_PATHS.BATCH_DEFAULT_SIZE),
          delay: getConfigValue(CONFIG_PATHS.BATCH_DELAY),
          cancellationToken: this.cancellationTokenSource.token,
          onProgress: (current, total) => {
            this.updateProgress(current, total, `\uCC98\uB9AC \uC911... (${current}/${total})`);
          }
        }
      );
    } catch (error) {
      if (error instanceof CancellationError) {
        new import_obsidian8.Notice("\uC791\uC5C5\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      } else {
        console.error("\uBC30\uCE58 \uCC98\uB9AC \uC911 \uC624\uB958:", error);
        new import_obsidian8.Notice("\uB2E8\uC5B4 \uCD94\uAC00 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
      }
    } finally {
      this.isProcessing = false;
      (_a = this.cancellationTokenSource) == null ? void 0 : _a.dispose();
      this.cancellationTokenSource = null;
      this.hideProgress();
      this.updateCancelButton(false);
      this.showResults(results);
    }
  }
  parseWords(inputText) {
    const sanitizedInput = sanitizeMarkdown(inputText);
    const rawWords = sanitizedInput.split("\n").map((word) => word.trim()).filter((word) => word.length > 0);
    const validation = validateBatch(rawWords, (word) => validateWord(word));
    if (validation.invalid.length > 0) {
      const invalidWords = validation.invalid.slice(0, 5).map((item) => item.item).join(", ");
      const moreCount = validation.invalid.length > 5 ? ` \uC678 ${validation.invalid.length - 5}\uAC1C` : "";
      new import_obsidian8.Notice(`\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uB2E8\uC5B4\uAC00 \uC81C\uC678\uB418\uC5C8\uC2B5\uB2C8\uB2E4: ${invalidWords}${moreCount}`);
    }
    const validWords = validation.valid.map((word) => validateWord(word).sanitized).map((word) => word.toLowerCase()).filter((word, index, array) => array.indexOf(word) === index);
    return validWords;
  }
  showProgress(totalWords) {
    const progressSection = this.contentEl.querySelector(".progress-section");
    const progressText = progressSection.querySelector(".progress-text");
    progressSection.removeClass("display-none");
    progressSection.addClass("display-block");
    progressText.textContent = `\uB2E8\uC5B4\uB97C \uCD94\uAC00\uD558\uB294 \uC911... (0/${totalWords})`;
  }
  updateProgress(current, total, message) {
    const progressSection = this.contentEl.querySelector(".progress-section");
    const progressText = progressSection.querySelector(".progress-text");
    const progressFill = progressSection.querySelector(".progress-fill");
    const percentage = current / total * 100;
    progressText.textContent = `${message} (${current}/${total})`;
    progressFill.style.width = `${percentage}%`;
  }
  hideProgress() {
    const progressSection = this.contentEl.querySelector(".progress-section");
    progressSection.removeClass("display-block");
    progressSection.addClass("display-none");
  }
  showResults(results) {
    const resultSection = this.contentEl.querySelector(".result-section");
    resultSection.removeClass("display-none");
    resultSection.addClass("display-block");
    resultSection.empty();
    const totalProcessed = results.success.length + results.failed.length + results.alreadyExists.length;
    const summaryEl = resultSection.createEl("div", { cls: "results-summary" });
    if (results.success.length > 0) {
      const successEl = summaryEl.createEl("div", { cls: "result-item success" });
      successEl.createEl("span", {
        text: `\u2705 \uC131\uACF5: ${results.success.length}\uAC1C`,
        cls: "result-count"
      });
      if (results.success.length <= 5) {
        successEl.createEl("p", {
          text: results.success.join(", "),
          cls: "result-words"
        });
      }
    }
    if (results.alreadyExists.length > 0) {
      const existsEl = summaryEl.createEl("div", { cls: "result-item warning" });
      existsEl.createEl("span", {
        text: `\u26A0\uFE0F \uC774\uBBF8 \uC874\uC7AC: ${results.alreadyExists.length}\uAC1C`,
        cls: "result-count"
      });
      if (results.alreadyExists.length <= 5) {
        existsEl.createEl("p", {
          text: results.alreadyExists.join(", "),
          cls: "result-words"
        });
      }
    }
    if (results.failed.length > 0) {
      const failedEl = summaryEl.createEl("div", { cls: "result-item error" });
      failedEl.createEl("span", {
        text: `\u274C \uC2E4\uD328: ${results.failed.length}\uAC1C`,
        cls: "result-count"
      });
      if (results.failed.length <= 5) {
        failedEl.createEl("p", {
          text: results.failed.join(", "),
          cls: "result-words"
        });
      }
    }
    const buttonSection = resultSection.createEl("div", { cls: "result-buttons" });
    const closeButton = buttonSection.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "close-button"
    });
    closeButton.addEventListener("click", () => this.close());
    const addMoreButton = buttonSection.createEl("button", {
      text: "\uB354 \uCD94\uAC00\uD558\uAE30",
      cls: "add-more-button"
    });
    addMoreButton.addEventListener("click", () => {
      resultSection.removeClass("display-block");
      resultSection.addClass("display-none");
      const textarea = this.contentEl.querySelector(".words-textarea");
      textarea.value = "";
      textarea.focus();
    });
    if (results.success.length > 0) {
      new import_obsidian8.Notice(`${results.success.length}\uAC1C\uC758 \uB2E8\uC5B4\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4!`);
    }
  }
  cancelOperation() {
    if (this.cancellationTokenSource) {
      this.cancellationTokenSource.cancel();
      new import_obsidian8.Notice("\uC791\uC5C5 \uCDE8\uC18C \uC911...");
    }
  }
  updateCancelButton(isProcessing) {
    const cancelButton = this.contentEl.querySelector(".cancel-button");
    if (cancelButton) {
      cancelButton.textContent = isProcessing ? "\uC791\uC5C5 \uCDE8\uC18C" : "\uCDE8\uC18C";
      cancelButton.classList.toggle("danger", isProcessing);
    }
  }
  onClose() {
    var _a;
    if (this.isProcessing && this.cancellationTokenSource) {
      this.cancellationTokenSource.cancel();
    }
    this.isProcessing = false;
    (_a = this.cancellationTokenSource) == null ? void 0 : _a.dispose();
    this.cancellationTokenSource = null;
    const { contentEl } = this;
    contentEl.empty();
    document.removeEventListener("bookCreated", this.handleBookCreated.bind(this));
  }
  openAddBookModal() {
    new AddBookModal(this.app, this.plugin).open();
  }
  async handleBookCreated(event) {
    await this.updateBookSelect();
  }
  async updateBookSelect() {
    await this.plugin.databaseManager.loadAllBooks();
    const books = this.plugin.databaseManager.getAllBooks();
    this.bookSelect.empty();
    books.forEach((book) => {
      const option = document.createElement("option");
      option.value = book.id;
      option.text = book.name;
      if (book.id === this.selectedBookId) {
        option.selected = true;
      }
      this.bookSelect.appendChild(option);
    });
  }
};

// src/features/book-management/ui/VocabularyManagerModal.ts
var VocabularyManagerModal = class extends import_obsidian9.Modal {
  constructor(app, plugin) {
    var _a;
    super(app);
    this.currentView = "list";
    this.selectedWords = /* @__PURE__ */ new Set();
    this.selectedBookId = "";
    this.plugin = plugin;
    this.databaseManager = plugin.databaseManager;
    this.wordService = new WordService();
    this.llmService = plugin.llmService;
    this.selectedBookId = ((_a = this.databaseManager.getCurrentBook()) == null ? void 0 : _a.id) || "default";
  }
  hasValidApiKey() {
    const provider = this.plugin.settings.llmProvider;
    switch (provider) {
      case "openai":
        return !!this.plugin.settings.openaiApiKey;
      case "anthropic":
        return !!this.plugin.settings.anthropicApiKey;
      case "google":
        return !!this.plugin.settings.googleApiKey;
      default:
        return false;
    }
  }
  async onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-manager-modal");
    contentEl.classList.add("wide-manager-modal");
    await this.databaseManager.loadAllBooks();
    this.selectedBookId = ((_a = this.databaseManager.getCurrentBook()) == null ? void 0 : _a.id) || "default";
    this.createBookSelectorHeader();
    this.createNavigation();
    this.showCurrentView();
    document.addEventListener("bookCreated", this.handleBookCreated.bind(this));
  }
  async handleBookCreated(event) {
    const newBook = event.detail;
    this.selectedBookId = newBook.id;
    await this.refreshBookSelector();
  }
  createBookSelectorHeader() {
    const headerEl = this.contentEl.createEl("div", { cls: "manager-header" });
    const books = this.databaseManager.getAllBooks();
    const bookSelect = headerEl.createEl("select", { cls: "book-select-dropdown" });
    books.forEach((book) => {
      const option = document.createElement("option");
      option.value = book.id;
      option.text = book.name;
      if (book.id === this.selectedBookId)
        option.selected = true;
      bookSelect.appendChild(option);
    });
    bookSelect.addEventListener("change", async (e) => {
      this.selectedBookId = e.target.value;
      await this.databaseManager.setCurrentBook(this.selectedBookId);
      this.showCurrentView();
    });
    const addBookBtn = headerEl.createEl("button", { text: "\uC0C8 \uB2E8\uC5B4\uC7A5 \uCD94\uAC00", cls: "book-manage-button" });
    addBookBtn.addEventListener("click", () => {
      const addBookModal = new AddBookModal(this.app, this.plugin);
      addBookModal.onClose = () => {
        this.refreshBookSelector();
      };
      addBookModal.open();
    });
    const delBookBtn = headerEl.createEl("button", { text: "\uD604\uC7AC \uB2E8\uC5B4\uC7A5 \uC0AD\uC81C", cls: "book-delete-button" });
    const isDefault = this.selectedBookId === "default";
    if (isDefault) {
      delBookBtn.setAttr("disabled", "true");
      delBookBtn.addClass("disabled");
    }
    delBookBtn.addEventListener("click", async () => {
      if (isDefault)
        return;
      const currentBook = this.databaseManager.getBook(this.selectedBookId);
      if (!currentBook) {
        new import_obsidian9.Notice("\uB2E8\uC5B4\uC7A5 \uC815\uBCF4\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const wordsInBook = this.databaseManager.getWordsByBook(this.selectedBookId);
      const wordCount = wordsInBook.length;
      const confirmModal = new ConfirmModal2(
        this.app,
        "\uB2E8\uC5B4\uC7A5 \uC0AD\uC81C \uD655\uC778",
        `\uC815\uB9D0\uB85C "${currentBook.name}" \uB2E8\uC5B4\uC7A5\uC744 \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?

\u2022 \uB2E8\uC5B4\uC7A5 \uC774\uB984: ${currentBook.name}
\u2022 \uD3EC\uD568\uB41C \uB2E8\uC5B4 \uC218: ${wordCount}\uAC1C
\u2022 \uC0DD\uC131\uC77C: ${new Date(currentBook.createdAt).toLocaleDateString("ko-KR")}

\u26A0\uFE0F \uC774 \uC791\uC5C5\uC740 \uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC73C\uBA70, \uB2E8\uC5B4\uC7A5\uACFC \uBAA8\uB4E0 \uB2E8\uC5B4\uAC00 \uC601\uAD6C\uC801\uC73C\uB85C \uC0AD\uC81C\uB429\uB2C8\uB2E4.`,
        async () => {
          try {
            await this.databaseManager.deleteBook(this.selectedBookId);
            this.selectedBookId = "default";
            await this.databaseManager.setCurrentBook("default");
            new import_obsidian9.Notice(`"${currentBook.name}" \uB2E8\uC5B4\uC7A5\uC774 \uC131\uACF5\uC801\uC73C\uB85C \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
            this.onOpen();
          } catch (e) {
            new import_obsidian9.Notice("\uB2E8\uC5B4\uC7A5 \uC0AD\uC81C \uC2E4\uD328: " + e.message);
          }
        }
      );
      confirmModal.open();
    });
  }
  createNavigation() {
    const navEl = this.contentEl.createEl("div", { cls: "manager-navigation" });
    const listBtn = navEl.createEl("button", { text: "\uB2E8\uC5B4 \uBAA9\uB85D", cls: "nav-button" });
    listBtn.addEventListener("click", () => {
      this.currentView = "list";
      this.showCurrentView();
    });
    const statsBtn = navEl.createEl("button", { text: "\uD1B5\uACC4", cls: "nav-button" });
    statsBtn.addEventListener("click", () => {
      this.currentView = "statistics";
      this.showCurrentView();
    });
    const addBtn = navEl.createEl("button", { text: "\uB2E8\uC5B4 \uCD94\uAC00", cls: "nav-button" });
    addBtn.addEventListener("click", () => {
      this.close();
      new AddWordsModal(this.app, this.plugin, this.selectedBookId).open();
    });
    const startLearningButton = navEl.createEl("button", {
      text: "\uC804\uCCB4 \uC601\uC5B4 \uB2E8\uC5B4 \uD559\uC2B5 \uC2DC\uC791",
      cls: "nav-button"
    });
    startLearningButton.addEventListener("click", () => {
      this.close();
      new VocabularyModal(this.app, this.plugin).open();
    });
  }
  showCurrentView() {
    const contentEl = this.contentEl.querySelector(".manager-content") || this.contentEl.createEl("div", { cls: "manager-content" });
    contentEl.empty();
    switch (this.currentView) {
      case "list":
        this.showWordList(contentEl);
        break;
      case "statistics":
        this.showStatistics(contentEl);
        break;
      case "add":
        this.showAddWord(contentEl);
        break;
    }
  }
  showWordList(container2) {
    const words = this.databaseManager.getAllWords();
    if (words.length === 0) {
      container2.createEl("p", {
        text: "\uB2E8\uC5B4\uC7A5\uC774 \uBE44\uC5B4\uC788\uC2B5\uB2C8\uB2E4. \uB2E8\uC5B4\uB97C \uCD94\uAC00\uD574\uBCF4\uC138\uC694!",
        cls: "empty-message"
      });
      return;
    }
    const searchEl = container2.createEl("div", { cls: "search-section" });
    const searchInput = searchEl.createEl("input", {
      type: "text",
      placeholder: "\uB2E8\uC5B4 \uAC80\uC0C9...",
      cls: "search-input"
    });
    const selectionControls = searchEl.createEl("div", { cls: "selection-controls" });
    const allSelected = this.selectedWords.size === words.length && words.length > 0;
    const selectAllBtn = selectionControls.createEl("button", {
      text: allSelected ? "\uC804\uCCB4 \uD574\uC81C" : "\uC804\uCCB4 \uC120\uD0DD",
      cls: "selection-button"
    });
    selectAllBtn.addEventListener("click", () => {
      if (this.selectedWords.size === words.length) {
        this.selectedWords.clear();
      } else {
        this.selectedWords.clear();
        words.forEach((word) => this.selectedWords.add(word.word));
      }
      this.showCurrentView();
    });
    const selectWordsWithoutMeaningsBtn = selectionControls.createEl("button", {
      text: "\uB73B \uC5C6\uB294 \uB2E8\uC5B4 \uC120\uD0DD",
      cls: "select-no-meanings-button"
    });
    selectWordsWithoutMeaningsBtn.addEventListener("click", () => {
      this.selectWordsWithoutMeanings(words);
    });
    const fetchSelectedButton = selectionControls.createEl("button", {
      text: "\uC120\uD0DD \uB2E8\uC5B4 \uB73B \uAC00\uC838\uC624\uAE30",
      cls: "fetch-selected-button"
    });
    fetchSelectedButton.addEventListener("click", () => {
      if (this.selectedWords.size === 0) {
        new import_obsidian9.Notice("\uC120\uD0DD\uB41C \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      this.showFetchSelectedMeaningsModal();
    });
    const wordListEl = container2.createEl("div", { cls: "word-list" });
    const renderWords = (filteredWords) => {
      wordListEl.empty();
      filteredWords.forEach((word) => {
        this.createWordItem(wordListEl, word);
      });
    };
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value;
      const filteredWords = query ? this.databaseManager.searchWords(query) : words;
      renderWords(filteredWords);
    });
    renderWords(words);
  }
  createWordItem(container2, word) {
    const wordEl = container2.createEl("div", { cls: "word-item" });
    const checkbox = wordEl.createEl("input", {
      type: "checkbox",
      cls: "word-checkbox"
    });
    checkbox.checked = this.selectedWords.has(word.word);
    checkbox.addEventListener("change", (e) => {
      const isChecked = e.target.checked;
      if (isChecked) {
        this.selectedWords.add(word.word);
      } else {
        this.selectedWords.delete(word.word);
      }
    });
    const wordHeader = wordEl.createEl("div", { cls: "word-header" });
    const wordTitleEl = wordHeader.createEl("h3", { cls: "word-title" });
    if (word.pronunciation && word.pronunciation.trim()) {
      wordTitleEl.textContent = word.word;
      wordTitleEl.appendText(" ");
      wordTitleEl.createEl("span", {
        text: `[${word.pronunciation}]`,
        cls: "pronunciation"
      });
    } else {
      wordTitleEl.textContent = word.word;
    }
    const difficultyBadge = wordHeader.createEl("span", {
      text: this.getDifficultyText(word.difficulty),
      cls: `difficulty-badge ${word.difficulty}`
    });
    const wordContent = wordEl.createEl("div", { cls: "word-content" });
    wordContent.createEl("p", {
      text: `\uB73B: ${word.meanings.join(", ")}`,
      cls: "word-meanings"
    });
    wordContent.createEl("p", {
      text: `\uBCF5\uC2B5 \uD69F\uC218: ${word.reviewCount}\uD68C`,
      cls: "review-count"
    });
    if (word.lastReviewed) {
      wordContent.createEl("p", {
        text: `\uB9C8\uC9C0\uB9C9 \uBCF5\uC2B5: ${formatDate(word.lastReviewed)}`,
        cls: "last-reviewed"
      });
    }
    const wordActions = wordEl.createEl("div", { cls: "word-actions" });
    if (this.plugin.settings.enableAdvancedFeatures) {
      const fetchButton = wordActions.createEl("button", {
        text: "\uB2E8\uC5B4 \uB73B \uAC00\uC838\uC624\uAE30",
        cls: "action-button fetch-single-button"
      });
      fetchButton.addEventListener("click", () => {
        this.fetchSingleWordMeaning(word);
      });
    }
    const deleteBtn = wordActions.createEl("button", {
      text: "\uC0AD\uC81C",
      cls: "action-button delete-button"
    });
    deleteBtn.addEventListener("click", async () => {
      const confirmModal = new ConfirmModal2(
        this.app,
        "\uB2E8\uC5B4 \uC0AD\uC81C",
        `"${word.word}" \uB2E8\uC5B4\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`,
        async () => {
          await this.databaseManager.removeWord(word.word);
          this.showCurrentView();
        }
      );
      confirmModal.open();
    });
  }
  showStatistics(container2) {
    const stats = this.databaseManager.getStatistics();
    const statsGrid = container2.createEl("div", { cls: "stats-grid" });
    const basicStats = statsGrid.createEl("div", { cls: "stats-section" });
    basicStats.createEl("h3", { text: "\uAE30\uBCF8 \uD1B5\uACC4", cls: "stats-title" });
    this.createStatItem(basicStats, "\uCD1D \uB2E8\uC5B4 \uC218", stats.totalWords.toString());
    this.createStatItem(basicStats, "\uCD1D \uBCF5\uC2B5 \uD69F\uC218", stats.totalReviews.toString());
    this.createStatItem(basicStats, "\uC5F0\uC18D \uD559\uC2B5\uC77C", `${stats.streakDays}\uC77C`);
    this.createStatItem(basicStats, "\uD3C9\uADE0 \uB09C\uC774\uB3C4", stats.averageDifficulty.toFixed(1));
    const difficultyStats = statsGrid.createEl("div", { cls: "stats-section" });
    difficultyStats.createEl("h3", { text: "\uB09C\uC774\uB3C4\uBCC4 \uBD84\uD3EC", cls: "stats-title" });
    this.createStatItem(difficultyStats, "\uC26C\uC6C0", stats.wordsByDifficulty.easy.toString());
    this.createStatItem(difficultyStats, "\uC88B\uC74C", stats.wordsByDifficulty.good.toString());
    this.createStatItem(difficultyStats, "\uC5B4\uB824\uC6C0", stats.wordsByDifficulty.hard.toString());
    const activityStats = statsGrid.createEl("div", { cls: "stats-section" });
    activityStats.createEl("h3", { text: "\uCD5C\uADFC 7\uC77C \uD65C\uB3D9", cls: "stats-title" });
    stats.recentActivity.forEach((activity) => {
      const date = new Date(activity.date).toLocaleDateString("ko-KR", {
        month: "short",
        day: "numeric"
      });
      this.createStatItem(
        activityStats,
        date,
        `\uD559\uC2B5: ${activity.wordsStudied}, \uBCF5\uC2B5: ${activity.reviewsCompleted}`
      );
    });
  }
  createStatItem(container2, label, value) {
    const statEl = container2.createEl("div", { cls: "stat-item" });
    statEl.createEl("span", { text: label, cls: "stat-label" });
    statEl.createEl("span", { text: value, cls: "stat-value" });
  }
  showAddWord(container2) {
    const addSection = container2.createEl("div", { cls: "add-word-section" });
    addSection.createEl("h3", { text: "\uC0C8 \uB2E8\uC5B4 \uCD94\uAC00", cls: "section-title" });
    const inputEl = addSection.createEl("div", { cls: "word-input-group" });
    const wordInput = inputEl.createEl("input", {
      type: "text",
      placeholder: "\uC601\uB2E8\uC5B4\uB97C \uC785\uB825\uD558\uC138\uC694 (\uC608: beautiful)",
      cls: "word-input"
    });
    const addButton = inputEl.createEl("button", {
      text: "\uB2E8\uC5B4 \uCD94\uAC00",
      cls: "add-button"
    });
    const addWord = async () => {
      const word = wordInput.value.trim();
      if (!word) {
        addSection.createEl("p", {
          text: "\uB2E8\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
          cls: "error-message"
        });
        return;
      }
      try {
        const wordData = await this.wordService.getWordData(word);
        const vocabularyCard = {
          ...wordData,
          reviewCount: 0,
          difficulty: "good",
          lastReviewed: null,
          addedDate: (/* @__PURE__ */ new Date()).toISOString(),
          bookId: this.selectedBookId
        };
        await this.databaseManager.addWord(vocabularyCard);
        wordInput.value = "";
        addSection.createEl("p", {
          text: `"${word}" \uB2E8\uC5B4\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4!`,
          cls: "success-message"
        });
        setTimeout(() => {
          const successMsg = addSection.querySelector(".success-message");
          if (successMsg)
            successMsg.remove();
        }, 3e3);
      } catch (error) {
        addSection.createEl("p", {
          text: "\uB2E8\uC5B4\uB97C \uCD94\uAC00\uD558\uB294 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
          cls: "error-message"
        });
      }
    };
    addButton.addEventListener("click", addWord);
    wordInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        addWord();
      }
    });
  }
  getDifficultyText(difficulty) {
    switch (difficulty) {
      case "none":
        return "\uBBF8\uD559\uC2B5";
      case "easy":
        return "\uC26C\uC6C0";
      case "good":
        return "\uC88B\uC74C";
      case "hard":
        return "\uC5B4\uB824\uC6C0";
      default:
        return "\uC88B\uC74C";
    }
  }
  startReview(words) {
    const reviewModal = new VocabularyReviewModal(this.app, this.plugin, words);
    reviewModal.open();
  }
  showFetchSelectedMeaningsModal() {
    const selectedWordList = Array.from(this.selectedWords);
    new FetchSelectedMeaningsModal(this.app, this.plugin, selectedWordList).open();
  }
  async fetchSingleWordMeaning(word) {
    if (!this.hasValidApiKey()) {
      new import_obsidian9.Notice("LLM API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const confirmModal = new ConfirmModal2(
      this.app,
      "\uB2E8\uC5B4 \uB73B \uAC00\uC838\uC624\uAE30",
      `"${word.word}" \uB2E8\uC5B4\uC758 \uB73B\uC744 \uC0C8\uB85C \uAC00\uC838\uC624\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? \uAE30\uC874 \uC815\uBCF4\uAC00\uC5B4\uC50C\uC6CC\uC9D1\uB2C8\uB2E4.`,
      async () => {
        try {
          new import_obsidian9.Notice(`"${word.word}" \uB2E8\uC5B4 \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294 \uC911...`);
          const llmResponse = await this.plugin.llmService.getWordDetails(word.word);
          if (llmResponse.success) {
            const wordDetail = llmResponse.data;
            const wordData = this.plugin.llmService.convertToWordData(wordDetail);
            const updatedWord = {
              ...word,
              meanings: wordData.meanings,
              examples: wordData.examples,
              similarWords: wordData.similarWords
            };
            await this.plugin.databaseManager.updateWordData(word.word, updatedWord);
            new import_obsidian9.Notice(`"${word.word}" \uB2E8\uC5B4 \uC815\uBCF4\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4!`);
            this.showCurrentView();
          } else {
            new import_obsidian9.Notice(`"${word.word}" \uB2E8\uC5B4 \uC815\uBCF4 \uAC00\uC838\uC624\uAE30 \uC2E4\uD328: ${llmResponse.error}`);
          }
        } catch (error) {
          console.error(`\uB2E8\uC5B4 "${word.word}" \uCC98\uB9AC \uC2E4\uD328:`, error);
          new import_obsidian9.Notice(`"${word.word}" \uB2E8\uC5B4 \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.`);
        }
      }
    );
    confirmModal.open();
  }
  async refreshBookSelector() {
    await this.databaseManager.loadAllBooks();
    const headerEl = this.contentEl.querySelector(".manager-header");
    if (headerEl) {
      const bookSelect = headerEl.querySelector(".book-select-dropdown");
      if (bookSelect) {
        const currentValue = bookSelect.value;
        const books = this.databaseManager.getAllBooks();
        bookSelect.empty();
        books.forEach((book) => {
          const option = document.createElement("option");
          option.value = book.id;
          option.text = book.name;
          if (book.id === currentValue || book.id === this.selectedBookId) {
            option.selected = true;
            this.selectedBookId = book.id;
          }
          bookSelect.appendChild(option);
        });
      }
    }
    this.showCurrentView();
  }
  selectWordsWithoutMeanings(words) {
    const wordsWithoutMeanings = words.filter((word) => {
      if (!word.meanings || word.meanings.length === 0) {
        return true;
      }
      if (word.meanings.length === 1 && word.meanings[0].trim() === "") {
        return true;
      }
      const invalidMeanings = word.meanings.filter((meaning) => {
        const cleanMeaning = meaning.trim();
        return cleanMeaning === "" || cleanMeaning === "\uC758\uBBF8\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4." || cleanMeaning === "Meaning not found" || cleanMeaning === "\uB73B\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4." || cleanMeaning.includes("\uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
      });
      return invalidMeanings.length === word.meanings.length;
    });
    if (wordsWithoutMeanings.length === 0) {
      new import_obsidian9.Notice("\uB73B\uC774 \uC5C6\uB294 \uB2E8\uC5B4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.selectedWords.clear();
    wordsWithoutMeanings.forEach((word) => {
      this.selectedWords.add(word.word);
    });
    new import_obsidian9.Notice(`${wordsWithoutMeanings.length}\uAC1C\uC758 \uB73B \uC5C6\uB294 \uB2E8\uC5B4\uB97C \uC120\uD0DD\uD588\uC2B5\uB2C8\uB2E4.`);
    this.showCurrentView();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    document.removeEventListener("bookCreated", this.handleBookCreated.bind(this));
  }
};
var VocabularyReviewModal = class extends import_obsidian9.Modal {
  constructor(app, plugin, words) {
    super(app);
    this.currentIndex = 0;
    this.showAnswer = false;
    this.plugin = plugin;
    this.words = words;
  }
  onOpen() {
    if (this.words.length === 0) {
      this.close();
      return;
    }
    this.showCurrentWord();
  }
  showCurrentWord() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vocabulary-learning-modal");
    contentEl.style.setProperty("--review-modal-height", `${this.plugin.settings.reviewModalHeight}vh`);
    const currentWord = this.words[this.currentIndex];
    const progressEl = contentEl.createEl("div", { cls: "review-progress" });
    progressEl.createEl("span", {
      text: `${this.currentIndex + 1} / ${this.words.length}`,
      cls: "progress-text"
    });
    const cardEl = contentEl.createEl("div", { cls: "review-card" });
    const deleteButton = cardEl.createEl("button", {
      text: "\uCE74\uB4DC \uC0AD\uC81C",
      cls: "card-delete-button"
    });
    deleteButton.addEventListener("click", () => this.handleDeleteCard());
    const wordEl = cardEl.createEl("h1", { cls: "review-word" });
    if (currentWord.pronunciation && currentWord.pronunciation.trim()) {
      wordEl.textContent = currentWord.word;
      wordEl.appendText(" ");
      wordEl.createEl("span", {
        text: `[${currentWord.pronunciation}]`,
        cls: "pronunciation"
      });
    } else {
      wordEl.textContent = currentWord.word;
    }
    if (!this.showAnswer) {
      if (currentWord.similarWords.length > 0) {
        const similarEl = cardEl.createEl("div", { cls: "similar-words" });
        similarEl.createEl("h3", { text: "\uC720\uC0AC\uD55C \uB2E8\uC5B4\uB4E4:" });
        const similarList = similarEl.createEl("ul");
        currentWord.similarWords.forEach((word) => {
          similarList.createEl("li", { text: word });
        });
      }
      if (currentWord.examples.length > 0) {
        const examplesEl = cardEl.createEl("div", { cls: "examples" });
        examplesEl.createEl("h3", { text: "\uC608\uBB38\uB4E4:" });
        currentWord.examples.forEach((example) => {
          examplesEl.createEl("p", { text: example.english, cls: "example" });
        });
      }
      const checkBtn = cardEl.createEl("button", {
        text: "\uC815\uB2F5 \uD655\uC778\uD558\uAE30",
        cls: "check-answer-button"
      });
      checkBtn.addEventListener("click", () => {
        this.showAnswer = true;
        this.showCurrentWord();
      });
    } else {
      const answerEl = cardEl.createEl("div", { cls: "answer-section" });
      answerEl.createEl("h3", { text: "\uB73B:" });
      const meaningsList = answerEl.createEl("ul");
      currentWord.meanings.forEach((meaning) => {
        meaningsList.createEl("li", { text: meaning });
      });
      if (currentWord.examples.length > 0) {
        answerEl.createEl("h3", { text: "\uC608\uBB38 \uBC88\uC5ED:" });
        currentWord.examples.forEach((example) => {
          answerEl.createEl("p", { text: example.korean, cls: "translation" });
        });
      }
      this.createReviewButtons(cardEl);
    }
  }
  createReviewButtons(container2) {
    const reviewSection = container2.createEl("div", { cls: "review-buttons" });
    const hardBtn = reviewSection.createEl("button", { text: "\uC5B4\uB824\uC6C0", cls: "review-btn hard" });
    const goodBtn = reviewSection.createEl("button", { text: "\uC88B\uC74C", cls: "review-btn good" });
    const easyBtn = reviewSection.createEl("button", { text: "\uC26C\uC6C0", cls: "review-btn easy" });
    hardBtn.addEventListener("click", () => this.handleReview("hard"));
    goodBtn.addEventListener("click", () => this.handleReview("good"));
    easyBtn.addEventListener("click", () => this.handleReview("easy"));
  }
  async handleReview(difficulty) {
    const currentWord = this.words[this.currentIndex];
    await this.plugin.databaseManager.updateWord(currentWord.word, difficulty);
    this.currentIndex++;
    this.showAnswer = false;
    if (this.currentIndex >= this.words.length) {
      this.showCompletion();
    } else {
      this.showCurrentWord();
    }
  }
  async handleDeleteCard() {
    const currentWord = this.words[this.currentIndex];
    const confirmModal = new ConfirmModal2(
      this.app,
      "\uB2E8\uC5B4 \uC0AD\uC81C",
      `"${currentWord.word}" \uB2E8\uC5B4\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?

\uC774 \uC791\uC5C5\uC740 \uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`,
      async () => {
        try {
          await this.plugin.databaseManager.removeWord(currentWord.word);
          this.words.splice(this.currentIndex, 1);
          if (this.words.length === 0) {
            this.showCompletion();
            return;
          }
          if (this.currentIndex >= this.words.length) {
            this.currentIndex = this.words.length - 1;
          }
          this.showAnswer = false;
          this.showCurrentWord();
        } catch (error) {
          console.error("\uB2E8\uC5B4 \uC0AD\uC81C \uC911 \uC624\uB958 \uBC1C\uC0DD:", error);
          new import_obsidian9.Notice("\uB2E8\uC5B4 \uC0AD\uC81C \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.");
        }
      }
    );
    confirmModal.open();
  }
  showCompletion() {
    const { contentEl } = this;
    contentEl.empty();
    const completionEl = contentEl.createEl("div", { cls: "completion" });
    completionEl.createEl("h2", { text: "\uBCF5\uC2B5 \uC644\uB8CC!" });
    completionEl.createEl("p", { text: "\uBAA8\uB4E0 \uB2E8\uC5B4\uB97C \uBCF5\uC2B5\uD588\uC2B5\uB2C8\uB2E4." });
    const closeBtn = completionEl.createEl("button", { text: "\uB2EB\uAE30", cls: "close-btn" });
    closeBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FetchSelectedMeaningsModal = class extends import_obsidian9.Modal {
  constructor(app, plugin, selectedWords) {
    super(app);
    this.isProcessing = false;
    this.plugin = plugin;
    this.selectedWords = selectedWords;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("fetch-selected-meanings-modal");
    contentEl.createEl("h2", {
      text: `\uC120\uD0DD\uB41C ${this.selectedWords.length}\uAC1C \uB2E8\uC5B4 \uB73B \uAC00\uC838\uC624\uAE30`,
      cls: "modal-title"
    });
    contentEl.createEl("p", {
      text: `\uC120\uD0DD\uB41C \uB2E8\uC5B4\uB4E4\uC758 \uC0C1\uC138 \uC815\uBCF4\uB97C LLM API\uB97C \uD1B5\uD574 \uAC00\uC838\uC635\uB2C8\uB2E4.`,
      cls: "modal-description"
    });
    const wordListEl = contentEl.createEl("div", { cls: "selected-words-list" });
    wordListEl.createEl("h3", { text: "\uC120\uD0DD\uB41C \uB2E8\uC5B4\uB4E4:" });
    const wordsContainer = wordListEl.createEl("div", { cls: "words-container" });
    this.selectedWords.forEach((word) => {
      wordsContainer.createEl("span", {
        text: word,
        cls: "selected-word-tag"
      });
    });
    const buttonSection = contentEl.createEl("div", { cls: "button-section" });
    const fetchButton = buttonSection.createEl("button", {
      text: "\uB73B \uAC00\uC838\uC624\uAE30",
      cls: "fetch-button"
    });
    fetchButton.addEventListener("click", () => {
      this.fetchSelectedMeanings();
    });
    const cancelButton = buttonSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "cancel-button"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const progressSection = contentEl.createEl("div", { cls: "progress-section display-none" });
    const progressText = progressSection.createEl("div", { cls: "progress-text" });
    const progressBar = progressSection.createEl("div", { cls: "progress-bar" });
    const progressFill = progressBar.createEl("div", { cls: "progress-fill" });
    const resultSection = contentEl.createEl("div", { cls: "result-section display-none" });
  }
  async fetchSelectedMeanings() {
    if (this.isProcessing)
      return;
    this.isProcessing = true;
    this.showProgress(this.selectedWords.length);
    try {
      const result = await this.plugin.llmService.getMultipleWordDetails(this.selectedWords);
      if (result.success && Array.isArray(result.data)) {
        const successWords = [];
        const failedWords = [];
        for (const wordData of result.data) {
          try {
            if (wordData.word && wordData.meanings && wordData.meanings.length > 0) {
              const existingWord = this.plugin.databaseManager.getWord(wordData.word);
              if (existingWord) {
                const updatedWord = {
                  ...existingWord,
                  pronunciation: wordData.pronunciation || "",
                  meanings: wordData.meanings,
                  examples: wordData.examples || [],
                  similarWords: wordData.similarWords || []
                };
                await this.plugin.databaseManager.updateWordData(wordData.word, updatedWord);
                successWords.push(wordData.word);
              }
            } else {
              failedWords.push(wordData.word);
            }
          } catch (error) {
            console.error(`\uB2E8\uC5B4 "${wordData.word}" \uC5C5\uB370\uC774\uD2B8 \uC2E4\uD328:`, error);
            failedWords.push(wordData.word);
          }
        }
        this.hideProgress();
        this.showResults({ success: successWords, failed: failedWords });
        if (successWords.length > 0) {
          new import_obsidian9.Notice(`${successWords.length}\uAC1C\uC758 \uB2E8\uC5B4 \uC815\uBCF4\uB97C \uC131\uACF5\uC801\uC73C\uB85C \uC5C5\uB370\uC774\uD2B8\uD588\uC2B5\uB2C8\uB2E4!`);
        }
      } else {
        this.hideProgress();
        new import_obsidian9.Notice("\uB2E8\uC5B4 \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294\uB370 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4: " + (result.error || "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958"));
      }
    } catch (error) {
      this.hideProgress();
      new import_obsidian9.Notice("\uB2E8\uC5B4 \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294\uB370 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4: " + error.message);
    } finally {
      this.isProcessing = false;
    }
  }
  showProgress(totalWords) {
    const progressSection = this.contentEl.querySelector(".progress-section");
    const progressText = progressSection.querySelector(".progress-text");
    progressSection.removeClass("display-none");
    progressSection.addClass("display-block");
    progressText.textContent = `\uB2E8\uC5B4 \uC815\uBCF4\uB97C \uAC00\uC838\uC624\uB294 \uC911... (0/${totalWords})`;
  }
  hideProgress() {
    const progressSection = this.contentEl.querySelector(".progress-section");
    if (progressSection) {
      progressSection.removeClass("display-block");
      progressSection.addClass("display-none");
    }
  }
  showResults(results) {
    const resultSection = this.contentEl.querySelector(".result-section");
    resultSection.removeClass("display-none");
    resultSection.addClass("display-block");
    resultSection.empty();
    const summaryEl = resultSection.createEl("div", { cls: "results-summary" });
    if (results.success.length > 0) {
      const successEl = summaryEl.createEl("div", { cls: "result-item success" });
      successEl.createEl("span", {
        text: `\u2705 \uC131\uACF5: ${results.success.length}\uAC1C`,
        cls: "result-count"
      });
      if (results.success.length <= 10) {
        successEl.createEl("p", {
          text: results.success.join(", "),
          cls: "result-words"
        });
      }
    }
    if (results.failed.length > 0) {
      const failedEl = summaryEl.createEl("div", { cls: "result-item error" });
      failedEl.createEl("span", {
        text: `\u274C \uC2E4\uD328: ${results.failed.length}\uAC1C`,
        cls: "result-count"
      });
      if (results.failed.length <= 10) {
        failedEl.createEl("p", {
          text: results.failed.join(", "),
          cls: "result-words"
        });
      }
    }
    const buttonSection = resultSection.createEl("div", { cls: "result-buttons" });
    const closeButton = buttonSection.createEl("button", { text: "\uB2EB\uAE30", cls: "close-button" });
    closeButton.addEventListener("click", () => this.close());
  }
  onClose() {
    this.isProcessing = false;
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal2 = class extends import_obsidian9.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("confirm-modal");
    contentEl.createEl("h2", { text: this.title, cls: "modal-title" });
    contentEl.createEl("p", { text: this.message, cls: "modal-message" });
    const buttonSection = contentEl.createEl("div", { cls: "button-section" });
    const confirmButton = buttonSection.createEl("button", {
      text: "\uD655\uC778",
      cls: "confirm-button primary"
    });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    const cancelButton = buttonSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "cancel-button"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/shared/container/DIContainer.ts
var DIContainer = class {
  constructor() {
    this.services = /* @__PURE__ */ new Map();
    this.instances = /* @__PURE__ */ new Map();
  }
  register(name, implementation, options = {}) {
    var _a, _b;
    this.services.set(name, {
      implementation,
      singleton: (_a = options.singleton) != null ? _a : true,
      dependencies: (_b = options.dependencies) != null ? _b : []
    });
  }
  resolve(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service '${name}' not registered`);
    }
    if (service.singleton && this.instances.has(name)) {
      return this.instances.get(name);
    }
    const dependencies = service.dependencies.map((dep) => this.resolve(dep));
    let instance;
    if (this.isConstructor(service.implementation)) {
      instance = new service.implementation(...dependencies);
    } else {
      instance = service.implementation(...dependencies);
    }
    if (service.singleton) {
      this.instances.set(name, instance);
    }
    return instance;
  }
  registerInstance(name, instance) {
    this.instances.set(name, instance);
    this.services.set(name, {
      implementation: () => instance,
      singleton: true,
      dependencies: []
    });
  }
  has(name) {
    return this.services.has(name);
  }
  clear() {
    this.services.clear();
    this.instances.clear();
  }
  isConstructor(implementation) {
    return implementation.prototype && implementation.prototype.constructor === implementation;
  }
};
var container = new DIContainer();

// src/core/entities/Vocabulary.ts
var VocabularyCard = class _VocabularyCard {
  constructor(word, pronunciation, meanings, similarWords, examples, reviewCount, difficulty, lastReviewed, addedDate, bookId) {
    this.word = word;
    this.pronunciation = pronunciation;
    this.meanings = meanings;
    this.similarWords = similarWords;
    this.examples = examples;
    this.reviewCount = reviewCount;
    this.difficulty = difficulty;
    this.lastReviewed = lastReviewed;
    this.addedDate = addedDate;
    this.bookId = bookId;
  }
  // 팩토리 메서드: WordData로부터 VocabularyCard 생성
  static fromWordData(wordData, bookId) {
    return new _VocabularyCard(
      wordData.word,
      wordData.pronunciation,
      wordData.meanings,
      wordData.similarWords,
      wordData.examples,
      0,
      // 초기 복습 횟수
      "none",
      // 초기 난이도 (학습 전)
      null,
      // 초기 복습 날짜
      (/* @__PURE__ */ new Date()).toISOString(),
      // 추가 날짜
      bookId
    );
  }
  // 비즈니스 로직: 복습 수행
  review(newDifficulty) {
    return new _VocabularyCard(
      this.word,
      this.pronunciation,
      this.meanings,
      this.similarWords,
      this.examples,
      this.reviewCount + 1,
      newDifficulty,
      (/* @__PURE__ */ new Date()).toISOString(),
      this.addedDate,
      this.bookId
    );
  }
  // 비즈니스 로직: 단어 정보 업데이트
  updateWordData(wordData) {
    var _a, _b, _c, _d;
    return new _VocabularyCard(
      this.word,
      (_a = wordData.pronunciation) != null ? _a : this.pronunciation,
      (_b = wordData.meanings) != null ? _b : this.meanings,
      (_c = wordData.similarWords) != null ? _c : this.similarWords,
      (_d = wordData.examples) != null ? _d : this.examples,
      this.reviewCount,
      this.difficulty,
      this.lastReviewed,
      this.addedDate,
      this.bookId
    );
  }
  // 비즈니스 로직: 단어장 이동
  moveToBook(newBookId) {
    return new _VocabularyCard(
      this.word,
      this.pronunciation,
      this.meanings,
      this.similarWords,
      this.examples,
      this.reviewCount,
      this.difficulty,
      this.lastReviewed,
      this.addedDate,
      newBookId
    );
  }
  // 비즈니스 로직: 복습이 필요한지 확인
  needsReview(reviewInterval = 1) {
    if (!this.lastReviewed)
      return true;
    const lastReviewDate = new Date(this.lastReviewed);
    const now = /* @__PURE__ */ new Date();
    const daysDiff = Math.floor((now.getTime() - lastReviewDate.getTime()) / (1e3 * 60 * 60 * 24));
    const difficultyMultiplier = {
      "none": 0,
      // 학습하지 않은 단어는 즉시 복습 필요
      "hard": 0.5,
      "good": 1,
      "easy": 2
    };
    if (this.difficulty === "none")
      return true;
    const adjustedInterval = reviewInterval * difficultyMultiplier[this.difficulty];
    return daysDiff >= adjustedInterval;
  }
  // 비즈니스 로직: 학습 진행도 계산 (0-100)
  getProgressPercentage() {
    const maxReviews = 10;
    const progress = Math.min(this.reviewCount / maxReviews, 1) * 100;
    const difficultyBonus = {
      "none": 0,
      // 학습하지 않은 단어는 보너스 없음
      "easy": 20,
      "good": 10,
      "hard": 0
    };
    return Math.min(progress + difficultyBonus[this.difficulty], 100);
  }
  // 데이터 직렬화를 위한 메서드
  toPlainObject() {
    return {
      word: this.word,
      pronunciation: this.pronunciation,
      meanings: this.meanings,
      similarWords: this.similarWords,
      examples: this.examples,
      reviewCount: this.reviewCount,
      difficulty: this.difficulty,
      lastReviewed: this.lastReviewed,
      addedDate: this.addedDate,
      bookId: this.bookId
    };
  }
  // 검증 로직
  validate() {
    const errors = [];
    if (!this.word || this.word.trim().length === 0) {
      errors.push("\uB2E8\uC5B4\uAC00 \uC785\uB825\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    }
    if (this.meanings.length === 0) {
      errors.push("\uB2E8\uC5B4\uC758 \uB73B\uC774 \uD558\uB098 \uC774\uC0C1 \uD544\uC694\uD569\uB2C8\uB2E4.");
    }
    if (!this.bookId || this.bookId.trim().length === 0) {
      errors.push("\uB2E8\uC5B4\uC7A5 ID\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.");
    }
    return errors;
  }
  static create(data) {
    var _a;
    return new _VocabularyCard(
      data.word,
      data.pronunciation || "",
      [data.meaning],
      // meanings array
      [],
      // similarWords
      ((_a = data.examples) == null ? void 0 : _a.map((ex) => ({ english: ex, korean: "" }))) || [],
      // examples with Example type
      0,
      // reviewCount
      "none",
      // difficulty - 초기 난이도 (학습 전)
      null,
      // lastReviewed
      (/* @__PURE__ */ new Date()).toISOString(),
      // addedDate
      data.bookId || "default"
    );
  }
};

// src/core/use-cases/AddWordUseCase.ts
var AddWordUseCase = class {
  constructor(vocabularyRepository, bookRepository, wordService) {
    this.vocabularyRepository = vocabularyRepository;
    this.bookRepository = bookRepository;
    this.wordService = wordService;
  }
  async execute(request) {
    try {
      if (!request.word || request.word.trim().length === 0) {
        return {
          success: false,
          error: "\uB2E8\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694."
        };
      }
      const word = request.word.trim().toLowerCase();
      const existingWord = await this.vocabularyRepository.findByWord(word);
      if (existingWord) {
        return {
          success: false,
          error: "\uC774\uBBF8 \uC874\uC7AC\uD558\uB294 \uB2E8\uC5B4\uC785\uB2C8\uB2E4."
        };
      }
      let bookId = request.bookId;
      if (!bookId) {
        const currentBook = await this.bookRepository.getCurrentBook();
        bookId = (currentBook == null ? void 0 : currentBook.id) || "default";
      }
      const book = await this.bookRepository.findById(bookId);
      if (!book) {
        return {
          success: false,
          error: "\uB2E8\uC5B4\uC7A5\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."
        };
      }
      const wordData = await this.wordService.getWordData(word);
      const vocabularyCard = VocabularyCard.create({
        word: wordData.word,
        meaning: wordData.meaning,
        pronunciation: wordData.pronunciation || "",
        examples: wordData.examples || [],
        bookId
      });
      const validationErrors = vocabularyCard.validate();
      if (validationErrors.length > 0) {
        return {
          success: false,
          error: validationErrors.join(", ")
        };
      }
      await this.vocabularyRepository.add(vocabularyCard);
      const event = {
        type: "WORD_ADDED",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        data: {
          word: vocabularyCard.word,
          bookId: vocabularyCard.bookId
        }
      };
      this.publishEvent(event);
      return {
        success: true,
        card: vocabularyCard
      };
    } catch (error) {
      console.error("AddWordUseCase \uC2E4\uD589 \uC911 \uC624\uB958:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."
      };
    }
  }
  publishEvent(event) {
    const customEvent = new CustomEvent("wordAdded", { detail: event.data });
    document.dispatchEvent(customEvent);
  }
};

// src/core/entities/Book.ts
var Book = class _Book {
  constructor(id, name, description, createdAt, updatedAt, wordCount, isDefault) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.wordCount = wordCount;
    this.isDefault = isDefault;
  }
  // 팩토리 메서드: 새 단어장 생성
  static create(name, description = "", isDefault = false) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const id = isDefault ? "default" : _Book.generateId();
    return new _Book(
      id,
      name,
      description,
      now,
      now,
      0,
      isDefault
    );
  }
  // 팩토리 메서드: 기본 단어장 생성
  static createDefault() {
    return _Book.create("\uAE30\uBCF8 \uB2E8\uC5B4\uC7A5", "\uAE30\uBCF8 \uB2E8\uC5B4\uC7A5\uC785\uB2C8\uB2E4.", true);
  }
  // 비즈니스 로직: 단어장 정보 업데이트
  updateInfo(name, description) {
    return new _Book(
      this.id,
      name != null ? name : this.name,
      description != null ? description : this.description,
      this.createdAt,
      (/* @__PURE__ */ new Date()).toISOString(),
      this.wordCount,
      this.isDefault
    );
  }
  // 비즈니스 로직: 단어 수 증가
  incrementWordCount() {
    return new _Book(
      this.id,
      this.name,
      this.description,
      this.createdAt,
      (/* @__PURE__ */ new Date()).toISOString(),
      this.wordCount + 1,
      this.isDefault
    );
  }
  // 비즈니스 로직: 단어 수 감소
  decrementWordCount() {
    return new _Book(
      this.id,
      this.name,
      this.description,
      this.createdAt,
      (/* @__PURE__ */ new Date()).toISOString(),
      Math.max(0, this.wordCount - 1),
      this.isDefault
    );
  }
  // 비즈니스 로직: 단어 수 재설정
  updateWordCount(count) {
    return new _Book(
      this.id,
      this.name,
      this.description,
      this.createdAt,
      (/* @__PURE__ */ new Date()).toISOString(),
      Math.max(0, count),
      this.isDefault
    );
  }
  // 비즈니스 로직: 삭제 가능 여부 확인
  canBeDeleted() {
    return !this.isDefault;
  }
  // 비즈니스 로직: 단어장이 비어있는지 확인
  isEmpty() {
    return this.wordCount === 0;
  }
  // 검증 로직
  validate() {
    const errors = [];
    if (!this.name || this.name.trim().length === 0) {
      errors.push("\uB2E8\uC5B4\uC7A5 \uC774\uB984\uC774 \uD544\uC694\uD569\uB2C8\uB2E4.");
    }
    if (this.name.trim().length > 100) {
      errors.push("\uB2E8\uC5B4\uC7A5 \uC774\uB984\uC740 100\uC790\uB97C \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
    if (this.description.length > 500) {
      errors.push("\uB2E8\uC5B4\uC7A5 \uC124\uBA85\uC740 500\uC790\uB97C \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
    if (this.wordCount < 0) {
      errors.push("\uB2E8\uC5B4 \uC218\uB294 0 \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.");
    }
    return errors;
  }
  // 데이터 직렬화를 위한 메서드
  toPlainObject() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      wordCount: this.wordCount,
      isDefault: this.isDefault
    };
  }
  // 비즈니스 로직: 생성일로부터 경과 일수 계산
  getDaysFromCreation() {
    const createdDate = new Date(this.createdAt);
    const now = /* @__PURE__ */ new Date();
    return Math.floor((now.getTime() - createdDate.getTime()) / (1e3 * 60 * 60 * 24));
  }
  // 비즈니스 로직: 마지막 업데이트로부터 경과 일수 계산
  getDaysFromLastUpdate() {
    const updatedDate = new Date(this.updatedAt);
    const now = /* @__PURE__ */ new Date();
    return Math.floor((now.getTime() - updatedDate.getTime()) / (1e3 * 60 * 60 * 24));
  }
  // ID 생성 유틸리티
  static generateId() {
    return `book_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/core/use-cases/CreateBookUseCase.ts
var CreateBookUseCase = class {
  constructor(bookRepository) {
    this.bookRepository = bookRepository;
  }
  async execute(request) {
    try {
      if (!request.name || request.name.trim().length === 0) {
        return {
          success: false,
          error: "\uB2E8\uC5B4\uC7A5 \uC774\uB984\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694."
        };
      }
      const name = request.name.trim();
      const existingBooks = await this.bookRepository.findAll();
      const duplicateBook = existingBooks.find(
        (book2) => book2.name.toLowerCase() === name.toLowerCase()
      );
      if (duplicateBook) {
        return {
          success: false,
          error: "\uC774\uBBF8 \uC874\uC7AC\uD558\uB294 \uB2E8\uC5B4\uC7A5 \uC774\uB984\uC785\uB2C8\uB2E4."
        };
      }
      const book = Book.create(
        name,
        request.description || ""
      );
      const validationErrors = book.validate();
      if (validationErrors.length > 0) {
        return {
          success: false,
          error: validationErrors.join(", ")
        };
      }
      await this.bookRepository.add(book);
      const event = {
        type: "BOOK_CREATED",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        data: {
          bookId: book.id,
          name: book.name
        }
      };
      this.publishEvent(event);
      return {
        success: true,
        book
      };
    } catch (error) {
      console.error("CreateBookUseCase \uC2E4\uD589 \uC911 \uC624\uB958:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."
      };
    }
  }
  publishEvent(event) {
    const customEvent = new CustomEvent("bookCreated", { detail: event.data });
    document.dispatchEvent(customEvent);
  }
};

// src/core/use-cases/GetWordsForReviewUseCase.ts
var GetWordsForReviewUseCase = class {
  constructor(vocabularyRepository, bookRepository) {
    this.vocabularyRepository = vocabularyRepository;
    this.bookRepository = bookRepository;
  }
  async execute(request = {}) {
    try {
      let bookId = request.bookId;
      if (!bookId) {
        const currentBook = await this.bookRepository.getCurrentBook();
        bookId = currentBook == null ? void 0 : currentBook.id;
      }
      const allWords = await this.vocabularyRepository.findByBookId(bookId);
      if (allWords.length === 0) {
        return {
          success: true,
          words: [],
          totalCount: 0
        };
      }
      const reviewInterval = request.reviewInterval || 1;
      const wordsNeedingReview = allWords.filter(
        (word) => word.needsReview(reviewInterval)
      );
      wordsNeedingReview.sort((a, b) => {
        if (a.lastReviewed && b.lastReviewed) {
          const aDate = new Date(a.lastReviewed).getTime();
          const bDate = new Date(b.lastReviewed).getTime();
          if (aDate !== bDate)
            return aDate - bDate;
        } else if (a.lastReviewed && !b.lastReviewed) {
          return -1;
        } else if (!a.lastReviewed && b.lastReviewed) {
          return 1;
        }
        const difficultyOrder = { "hard": 3, "good": 2, "easy": 1 };
        const difficultyDiff = difficultyOrder[b.difficulty] - difficultyOrder[a.difficulty];
        if (difficultyDiff !== 0)
          return difficultyDiff;
        return a.reviewCount - b.reviewCount;
      });
      const limit = request.limit || 20;
      const limitedWords = wordsNeedingReview.slice(0, limit);
      return {
        success: true,
        words: limitedWords,
        totalCount: wordsNeedingReview.length
      };
    } catch (error) {
      console.error("GetWordsForReviewUseCase \uC2E4\uD589 \uC911 \uC624\uB958:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."
      };
    }
  }
};

// src/core/use-cases/ReviewWordUseCase.ts
var ReviewWordUseCase = class {
  constructor(vocabularyRepository) {
    this.vocabularyRepository = vocabularyRepository;
  }
  async execute(request) {
    try {
      if (!request.word || request.word.trim().length === 0) {
        return {
          success: false,
          error: "\uB2E8\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694."
        };
      }
      if (!["easy", "good", "hard"].includes(request.difficulty)) {
        return {
          success: false,
          error: "\uC62C\uBC14\uB978 \uB09C\uC774\uB3C4\uB97C \uC120\uD0DD\uD574\uC8FC\uC138\uC694."
        };
      }
      const word = request.word.trim().toLowerCase();
      const existingCard = await this.vocabularyRepository.findByWord(word);
      if (!existingCard) {
        return {
          success: false,
          error: "\uB2E8\uC5B4\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."
        };
      }
      const previousDifficulty = existingCard.difficulty;
      const reviewedCard = existingCard.review(request.difficulty);
      await this.vocabularyRepository.update(reviewedCard);
      const event = {
        type: "WORD_REVIEWED",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        data: {
          word: reviewedCard.word,
          difficulty: request.difficulty,
          previousDifficulty
        }
      };
      this.publishEvent(event);
      return {
        success: true,
        card: reviewedCard
      };
    } catch (error) {
      console.error("ReviewWordUseCase \uC2E4\uD589 \uC911 \uC624\uB958:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4."
      };
    }
  }
  publishEvent(event) {
    const customEvent = new CustomEvent("wordReviewed", { detail: event.data });
    document.dispatchEvent(customEvent);
  }
};

// src/infrastructure/obsidian/repositories/VocabularyRepositoryAdapter.ts
var VocabularyRepositoryAdapter = class {
  constructor(databaseManager) {
    this.databaseManager = databaseManager;
  }
  async add(card) {
    await this.databaseManager.addWord(card);
  }
  async save(card) {
    await this.databaseManager.addWord(card);
  }
  async findByWord(word) {
    return this.databaseManager.getWord(word);
  }
  async findAll() {
    return this.databaseManager.getAllWords();
  }
  async findByBookId(bookId) {
    return this.databaseManager.getWordsByBook(bookId);
  }
  async update(word, card) {
    await this.databaseManager.updateWord(word, card.difficulty);
  }
  async delete(word) {
    await this.databaseManager.removeWord(word);
  }
  async search(options) {
    const allWords = await this.findAll();
    const filteredWords = allWords.filter(
      (word) => {
        var _a;
        return word.word.toLowerCase().includes(((_a = options.query) == null ? void 0 : _a.toLowerCase()) || "");
      }
    );
    return {
      words: filteredWords,
      total: filteredWords.length,
      hasMore: false
    };
  }
  async searchByText(query) {
    const result = await this.search({ query });
    return result.words;
  }
  async findCardsForReview(bookId) {
    return this.databaseManager.getWordsForReview(bookId);
  }
  async findCardsByDifficulty(difficulty, bookId) {
    const words = bookId ? await this.findByBookId(bookId) : await this.findAll();
    return words.filter((word) => word.difficulty === difficulty);
  }
  async count() {
    const words = await this.findAll();
    return words.length;
  }
  async countByBookId(bookId) {
    const words = await this.findByBookId(bookId);
    return words.length;
  }
  async countByDifficulty(difficulty) {
    const words = await this.findCardsByDifficulty(difficulty);
    return words.length;
  }
  async saveMany(cards) {
    for (const card of cards) {
      await this.add(card);
    }
  }
  async deleteMany(words) {
    for (const word of words) {
      await this.delete(word);
    }
  }
  async loadData() {
    await this.databaseManager.loadAllBooks();
  }
  async saveData() {
    await this.databaseManager.saveAllData();
  }
  onDataChanged(callback) {
  }
  offDataChanged(callback) {
  }
};

// src/infrastructure/obsidian/repositories/BookRepositoryAdapter.ts
var BookRepositoryAdapter = class {
  constructor(databaseManager) {
    this.databaseManager = databaseManager;
  }
  async add(book) {
    await this.databaseManager.createBook(book.toPlainObject());
  }
  async save(book) {
    await this.databaseManager.createBook(book.toPlainObject());
  }
  async findById(id) {
    const bookData = this.databaseManager.getBook(id);
    if (!bookData)
      return null;
    return new Book(
      bookData.id,
      bookData.name,
      bookData.description,
      bookData.createdAt,
      bookData.updatedAt,
      bookData.wordCount,
      bookData.isDefault
    );
  }
  async findAll(options) {
    const booksData = this.databaseManager.getAllBooks();
    let books = booksData.map((bookData) => new Book(
      bookData.id,
      bookData.name,
      bookData.description,
      bookData.createdAt,
      bookData.updatedAt,
      bookData.wordCount,
      bookData.isDefault
    ));
    if (options) {
      if (options.includeEmpty === false) {
        books = books.filter((book) => !book.isEmpty());
      }
      if (options.sortBy) {
        books.sort((a, b) => {
          const aValue = a[options.sortBy];
          const bValue = b[options.sortBy];
          if (typeof aValue === "string" && typeof bValue === "string") {
            return options.sortOrder === "desc" ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
          }
          if (typeof aValue === "number" && typeof bValue === "number") {
            return options.sortOrder === "desc" ? bValue - aValue : aValue - bValue;
          }
          return 0;
        });
      }
      if (options.offset || options.limit) {
        const start = options.offset || 0;
        const end = options.limit ? start + options.limit : void 0;
        books = books.slice(start, end);
      }
    }
    return books;
  }
  async update(id, book) {
    await this.databaseManager.updateBook(id, book.toPlainObject());
  }
  async delete(id) {
    await this.databaseManager.deleteBook(id);
  }
  async findDefault() {
    return this.findById("default");
  }
  async findByName(name) {
    const books = await this.findAll();
    return books.find((book) => book.name === name) || null;
  }
  async exists(id) {
    const book = await this.findById(id);
    return book !== null;
  }
  async count() {
    const books = await this.findAll();
    return books.length;
  }
  async getStatistics(bookId) {
    const book = await this.findById(bookId);
    if (!book)
      return null;
    const words = this.databaseManager.getWordsByBook(bookId);
    const wordsByDifficulty = {
      easy: words.filter((w) => w.difficulty === "easy").length,
      good: words.filter((w) => w.difficulty === "good").length,
      hard: words.filter((w) => w.difficulty === "hard").length
    };
    const totalReviews = words.reduce((sum, word) => sum + word.reviewCount, 0);
    const averageReviewCount = words.length > 0 ? totalReviews / words.length : 0;
    const lastActivityDate = words.length > 0 ? Math.max(...words.map((w) => new Date(w.lastReviewed || w.addedDate).getTime())) : null;
    const completionPercentage = words.length > 0 ? wordsByDifficulty.easy / words.length * 100 : 0;
    return {
      book,
      totalWords: words.length,
      wordsByDifficulty,
      averageReviewCount,
      lastActivityDate: lastActivityDate ? new Date(lastActivityDate).toISOString() : null,
      completionPercentage
    };
  }
  async getAllStatistics() {
    const books = await this.findAll();
    const statistics = [];
    for (const book of books) {
      const stat = await this.getStatistics(book.id);
      if (stat) {
        statistics.push(stat);
      }
    }
    return statistics;
  }
  async getCurrentBook() {
    const currentBook = this.databaseManager.getCurrentBook();
    if (!currentBook)
      return null;
    return new Book(
      currentBook.id,
      currentBook.name,
      currentBook.description,
      currentBook.createdAt,
      currentBook.updatedAt,
      currentBook.wordCount,
      currentBook.isDefault
    );
  }
  async setCurrentBook(bookId) {
    await this.databaseManager.setCurrentBook(bookId);
  }
  async loadData() {
    await this.databaseManager.loadAllBooks();
  }
  async saveData() {
    await this.databaseManager.saveAllData();
  }
  async validateBookName(name, excludeId) {
    const books = await this.findAll();
    return !books.some(
      (book) => book.name === name && (!excludeId || book.id !== excludeId)
    );
  }
  onDataChanged(callback) {
  }
  offDataChanged(callback) {
  }
  onCurrentBookChanged(callback) {
  }
  offCurrentBookChanged(callback) {
  }
};

// src/infrastructure/storage/VocabularyDatabase.ts
var import_obsidian10 = require("obsidian");
var VocabularyDatabaseManager = class {
  constructor(app, saveCallback, folderPath) {
    this.books = /* @__PURE__ */ new Map();
    this.words = /* @__PURE__ */ new Map();
    this.settings = {
      dailyGoal: 10,
      reviewInterval: 1,
      currentBookId: "default"
    };
    this.statistics = {
      totalReviews: 0,
      streakDays: 0,
      lastStudyDate: null
    };
    this.vocabularyFolderPath = "Vocabulary";
    this.app = app;
    this.saveCallback = saveCallback;
    if (folderPath) {
      this.vocabularyFolderPath = folderPath;
    }
    this.initializeVocabularyFolder();
    this.initializeDefaultBook();
  }
  // 단어장 폴더 초기화
  async initializeVocabularyFolder() {
    try {
      const folder = this.app.vault.getAbstractFileByPath(this.vocabularyFolderPath);
      if (folder instanceof import_obsidian10.TFolder) {
        return;
      }
      await this.app.vault.createFolder(this.vocabularyFolderPath);
    } catch (error) {
      if (error instanceof Error) {
        const errorMessage = error.message.toLowerCase();
        if (errorMessage.includes("already exists") || errorMessage.includes("folder already exists") || errorMessage.includes("already present")) {
        } else {
          console.warn("\uB2E8\uC5B4\uC7A5 \uD3F4\uB354 \uC0DD\uC131 \uC2E4\uD328:", error);
        }
      } else {
        console.warn("\uB2E8\uC5B4\uC7A5 \uD3F4\uB354 \uC0DD\uC131 \uC911 \uC54C \uC218 \uC5C6\uB294 \uC624\uB958 \uBC1C\uC0DD:", error);
      }
    }
  }
  // 기본 book 초기화
  async initializeDefaultBook() {
    if (!this.books.has("default")) {
      const defaultBook = {
        id: "default",
        name: "\uAE30\uBCF8 \uB2E8\uC5B4\uC7A5",
        description: "\uAE30\uBCF8 \uB2E8\uC5B4\uC7A5\uC785\uB2C8\uB2E4.",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        wordCount: 0,
        isDefault: true
      };
      this.books.set("default", defaultBook);
      await this.saveBookToFile(defaultBook);
    }
  }
  // Book을 MD 파일로 저장
  async saveBookToFile(book) {
    const bookName = typeof book.name === "string" ? book.name : "untitled";
    const fileName = `${bookName.replace(/[<>:"/\\|?*]/g, "_")}.md`;
    const filePath = (0, import_obsidian10.normalizePath)(`${this.vocabularyFolderPath}/${fileName}`);
    const bookWords = Array.from(this.words.values()).filter((word) => word.bookId === book.id).sort((a, b) => {
      const wordA = typeof a.word === "string" ? a.word : "";
      const wordB = typeof b.word === "string" ? b.word : "";
      return wordA.localeCompare(wordB);
    });
    const frontmatter = [
      "---",
      `bookId: ${book.id}`,
      `name: "${book.name}"`,
      `description: "${book.description}"`,
      `createdAt: ${book.createdAt}`,
      `updatedAt: ${book.updatedAt}`,
      `wordCount: ${bookWords.length}`,
      `isDefault: ${book.isDefault}`,
      "---",
      ""
    ].join("\n");
    let content = frontmatter;
    content += `# ${book.name}

`;
    content += `${book.description}

`;
    content += `## \uB2E8\uC5B4 \uBAA9\uB85D (${bookWords.length}\uAC1C)

`;
    for (const word of bookWords) {
      content += `### ${word.word}

`;
      if (word.pronunciation) {
        content += `**\uBC1C\uC74C:** ${word.pronunciation}

`;
      }
      content += `**\uB73B:**
`;
      for (const meaning of word.meanings) {
        content += `- ${meaning}
`;
      }
      content += "\n";
      if (word.similarWords.length > 0) {
        content += `**\uC720\uC0AC\uD55C \uB2E8\uC5B4:** ${word.similarWords.join(", ")}

`;
      }
      if (word.examples.length > 0) {
        content += `**\uC608\uBB38:**
`;
        for (const example of word.examples) {
          content += `- ${example.english}
`;
          content += `  - ${example.korean}
`;
        }
        content += "\n";
      }
      content += `**\uBCF5\uC2B5 \uC815\uBCF4:**
`;
      content += `- \uBCF5\uC2B5 \uD69F\uC218: ${word.reviewCount}
`;
      content += `- \uB09C\uC774\uB3C4: ${word.difficulty}
`;
      content += `- \uB9C8\uC9C0\uB9C9 \uBCF5\uC2B5: ${word.lastReviewed || "\uC5C6\uC74C"}
`;
      content += `- \uCD94\uAC00\uC77C: ${word.addedDate}
`;
      if (word.scheduleInfo) {
        content += `
**\uC2A4\uD398\uC774\uC2A4\uB4DC \uB9AC\uD53C\uD2F0\uC158:**
`;
        content += `- \uB2E4\uC74C \uBCF5\uC2B5\uC77C: ${word.scheduleInfo.dueDate}
`;
        content += `- \uBCF5\uC2B5 \uAC04\uACA9: ${word.scheduleInfo.interval}\uC77C
`;
        content += `- \uC6A9\uC774\uB3C4: ${word.scheduleInfo.ease}
`;
        content += `- \uC2E4\uD328 \uD69F\uC218: ${word.scheduleInfo.lapseCount}
`;
      }
      content += "\n---\n\n";
    }
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian10.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        try {
          await this.app.vault.create(filePath, content);
        } catch (error) {
          if (error instanceof Error && error.message.includes("already exists")) {
            const file = this.app.vault.getAbstractFileByPath(filePath);
            if (file instanceof import_obsidian10.TFile) {
              await this.app.vault.modify(file, content);
            } else {
            }
          } else {
            console.error("\uB2E8\uC5B4\uC7A5 \uD30C\uC77C \uC800\uC7A5 \uC2E4\uD328:", error);
          }
        }
      }
    } catch (error) {
      console.error("\uB2E8\uC5B4\uC7A5 \uD30C\uC77C \uC800\uC7A5 \uC2E4\uD328:", error);
    }
  }
  // MD 파일에서 Book과 단어들 로드
  async loadBookFromFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const { frontmatter, body } = this.parseMDFile(content);
      if (!frontmatter.bookId)
        return;
      const book = {
        id: frontmatter.bookId,
        name: frontmatter.name || file.basename,
        description: frontmatter.description || "",
        createdAt: frontmatter.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: frontmatter.updatedAt || (/* @__PURE__ */ new Date()).toISOString(),
        wordCount: frontmatter.wordCount || 0,
        isDefault: frontmatter.isDefault || false
      };
      this.books.set(book.id, book);
      const words = this.parseWordsFromMarkdown(body, book.id);
      for (const word of words) {
        this.words.set(word.word.toLowerCase(), word);
      }
    } catch (error) {
      console.error("\uB2E8\uC5B4\uC7A5 \uD30C\uC77C \uB85C\uB4DC \uC2E4\uD328:", error);
    }
  }
  // MD 파일 파싱 (frontmatter와 body 분리)
  parseMDFile(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return { frontmatter: {}, body: content };
    }
    const frontmatterText = match[1];
    const body = match[2];
    const frontmatter = {};
    const lines = frontmatterText.split("\n");
    for (const line of lines) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.substring(0, colonIndex).trim();
        let value = line.substring(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"')) {
          value = value.slice(1, -1);
        }
        if (value === "true")
          frontmatter[key] = true;
        else if (value === "false")
          frontmatter[key] = false;
        else if (!isNaN(Number(value)))
          frontmatter[key] = Number(value);
        else
          frontmatter[key] = value;
      }
    }
    return { frontmatter, body };
  }
  // 마크다운에서 단어들 파싱
  parseWordsFromMarkdown(markdown, bookId) {
    const words = [];
    const wordSections = markdown.split("---").filter((section) => section.trim());
    for (const section of wordSections) {
      const word = this.parseWordSection(section, bookId);
      if (word) {
        words.push(word);
      }
    }
    return words;
  }
  // 개별 단어 섹션 파싱
  parseWordSection(section, bookId) {
    const lines = section.split("\n").filter((line) => line.trim());
    if (lines.length === 0)
      return null;
    let word = "";
    let pronunciation = "";
    const meanings = [];
    const similarWords = [];
    const examples = [];
    let reviewCount = 0;
    let difficulty = "none";
    let lastReviewed = null;
    let addedDate = (/* @__PURE__ */ new Date()).toISOString();
    let scheduleInfo = void 0;
    let currentSection = "";
    let currentExample = {};
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("### ")) {
        word = trimmedLine.substring(4).trim();
        continue;
      }
      if (trimmedLine.startsWith("**\uBC1C\uC74C:**")) {
        pronunciation = trimmedLine.substring(7).trim();
        currentSection = "pronunciation";
      } else if (trimmedLine.startsWith("**\uB73B:**")) {
        currentSection = "meanings";
      } else if (trimmedLine.startsWith("**\uC720\uC0AC\uD55C \uB2E8\uC5B4:**")) {
        const similarWordsText = trimmedLine.substring(12).trim();
        similarWords.push(...similarWordsText.split(",").map((w) => w.trim()));
        currentSection = "similar";
      } else if (trimmedLine.startsWith("**\uC608\uBB38:**")) {
        currentSection = "examples";
      } else if (trimmedLine.startsWith("**\uBCF5\uC2B5 \uC815\uBCF4:**")) {
        currentSection = "review";
      } else if (trimmedLine.startsWith("**\uC2A4\uD398\uC774\uC2A4\uB4DC \uB9AC\uD53C\uD2F0\uC158:**")) {
        currentSection = "spaced-repetition";
      } else if (currentSection === "meanings" && trimmedLine.startsWith("- ")) {
        meanings.push(trimmedLine.substring(2).trim());
      } else if (currentSection === "examples") {
        if (line.startsWith("- ") && !line.startsWith("  - ")) {
          if (currentExample.english && currentExample.korean) {
            examples.push({
              english: currentExample.english,
              korean: currentExample.korean
            });
          }
          currentExample = { english: line.substring(2).trim() };
        } else if (line.startsWith("  - ")) {
          currentExample.korean = line.substring(4).trim();
        }
      } else if (currentSection === "review") {
        if (trimmedLine.startsWith("- \uBCF5\uC2B5 \uD69F\uC218: ")) {
          reviewCount = parseInt(trimmedLine.substring(9).trim()) || 0;
        } else if (trimmedLine.startsWith("- \uB09C\uC774\uB3C4: ")) {
          const diff = trimmedLine.substring(7).trim();
          if (diff === "easy" || diff === "good" || diff === "hard") {
            difficulty = diff;
          }
        } else if (trimmedLine.startsWith("- \uB9C8\uC9C0\uB9C9 \uBCF5\uC2B5: ")) {
          const lastRev = trimmedLine.substring(11).trim();
          lastReviewed = lastRev === "\uC5C6\uC74C" ? null : lastRev;
        } else if (trimmedLine.startsWith("- \uCD94\uAC00\uC77C: ")) {
          addedDate = trimmedLine.substring(7).trim();
        }
      } else if (currentSection === "spaced-repetition") {
        if (!scheduleInfo) {
          scheduleInfo = {};
        }
        if (trimmedLine.startsWith("- \uB2E4\uC74C \uBCF5\uC2B5\uC77C: ")) {
          scheduleInfo.dueDate = trimmedLine.substring(10).trim();
        } else if (trimmedLine.startsWith("- \uBCF5\uC2B5 \uAC04\uACA9: ")) {
          const intervalText = trimmedLine.substring(8).trim();
          scheduleInfo.interval = parseInt(intervalText.replace("\uC77C", "")) || 1;
        } else if (trimmedLine.startsWith("- \uC6A9\uC774\uB3C4: ")) {
          scheduleInfo.ease = parseInt(trimmedLine.substring(7).trim()) || 250;
        } else if (trimmedLine.startsWith("- \uC2E4\uD328 \uD69F\uC218: ")) {
          scheduleInfo.lapseCount = parseInt(trimmedLine.substring(9).trim()) || 0;
        }
      }
    }
    if (currentExample.english && currentExample.korean) {
      examples.push({
        english: currentExample.english,
        korean: currentExample.korean
      });
    }
    if (!word)
      return null;
    return {
      word: word.toLowerCase(),
      pronunciation,
      meanings,
      similarWords,
      examples,
      reviewCount,
      difficulty,
      lastReviewed,
      addedDate,
      bookId,
      scheduleInfo
    };
  }
  // 모든 단어장 파일 로드
  async loadAllBooks() {
    this.books.clear();
    this.words.clear();
    await this.initializeVocabularyFolder();
    await this.initializeDefaultBook();
    const folder = this.app.vault.getAbstractFileByPath(this.vocabularyFolderPath);
    if (folder instanceof import_obsidian10.TFolder) {
      for (const file of folder.children) {
        if (file instanceof import_obsidian10.TFile && file.extension === "md") {
          await this.loadBookFromFile(file);
        }
      }
    }
    await this.loadSettings();
  }
  // 설정 파일 저장/로드
  async saveSettings() {
    const settingsPath = (0, import_obsidian10.normalizePath)(`${this.vocabularyFolderPath}/settings.json`);
    const data = {
      settings: this.settings,
      statistics: this.statistics
    };
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(settingsPath);
      const content = JSON.stringify(data, null, 2);
      if (existingFile instanceof import_obsidian10.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(settingsPath, content);
      }
    } catch (error) {
      console.error("\uC124\uC815 \uD30C\uC77C \uC800\uC7A5 \uC2E4\uD328:", error);
    }
  }
  async loadSettings() {
    const settingsPath = (0, import_obsidian10.normalizePath)(`${this.vocabularyFolderPath}/settings.json`);
    try {
      const file = this.app.vault.getAbstractFileByPath(settingsPath);
      if (file instanceof import_obsidian10.TFile) {
        const content = await this.app.vault.read(file);
        const data = JSON.parse(content);
        if (data.settings) {
          this.settings = { ...this.settings, ...data.settings };
        }
        if (data.statistics) {
          this.statistics = { ...this.statistics, ...data.statistics };
        }
      }
    } catch (error) {
      console.warn("\uC124\uC815 \uD30C\uC77C \uB85C\uB4DC \uC2E4\uD328, \uAE30\uBCF8\uAC12 \uC0AC\uC6A9:", error);
    }
  }
  // Book 관리 메서드들
  async createBook(name, description = "") {
    const id = `book_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const book = {
      id,
      name,
      description,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      wordCount: 0,
      isDefault: false
    };
    this.books.set(id, book);
    await this.saveBookToFile(book);
    this.saveCallback();
    return book;
  }
  async updateBook(bookId, updates) {
    const book = this.books.get(bookId);
    if (!book) {
      throw new Error(`Book "${bookId}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    const updatedBook = {
      ...book,
      ...updates,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.books.set(bookId, updatedBook);
    await this.saveBookToFile(updatedBook);
    this.saveCallback();
  }
  async deleteBook(bookId) {
    if (bookId === "default") {
      throw new Error("\uAE30\uBCF8 \uB2E8\uC5B4\uC7A5\uC740 \uC0AD\uC81C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
    const book = this.books.get(bookId);
    if (!book) {
      throw new Error(`Book "${bookId}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    const wordsToDelete = Array.from(this.words.values()).filter((word) => word.bookId === bookId).map((word) => word.word);
    for (const word of wordsToDelete) {
      this.words.delete(word.toLowerCase());
    }
    this.books.delete(bookId);
    const fileName = `${book.name.replace(/[<>:"/\\|?*]/g, "_")}.md`;
    const filePath = (0, import_obsidian10.normalizePath)(`${this.vocabularyFolderPath}/${fileName}`);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian10.TFile) {
      await this.app.fileManager.trashFile(file);
    }
    if (this.settings.currentBookId === bookId) {
      this.settings.currentBookId = "default";
      await this.saveSettings();
    }
    this.saveCallback();
  }
  getAllBooks() {
    return Array.from(this.books.values()).sort((a, b) => {
      if (a.isDefault)
        return -1;
      if (b.isDefault)
        return 1;
      const nameA = typeof a.name === "string" ? a.name : "";
      const nameB = typeof b.name === "string" ? b.name : "";
      return nameA.localeCompare(nameB);
    });
  }
  getBook(bookId) {
    return this.books.get(bookId);
  }
  getCurrentBook() {
    return this.books.get(this.settings.currentBookId);
  }
  async setCurrentBook(bookId) {
    if (!this.books.has(bookId)) {
      throw new Error(`Book "${bookId}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    this.settings.currentBookId = bookId;
    await this.saveSettings();
    this.saveCallback();
  }
  // Book별 단어 수 업데이트
  updateBookWordCount(bookId) {
    const wordCount = Array.from(this.words.values()).filter((word) => word.bookId === bookId).length;
    const book = this.books.get(bookId);
    if (book) {
      book.wordCount = wordCount;
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    }
  }
  // 단어 추가
  async addWord(wordData) {
    const word = wordData.word.toLowerCase();
    if (this.words.has(word)) {
      throw new Error(`\uB2E8\uC5B4 "${wordData.word}"\uB294 \uC774\uBBF8 \uC874\uC7AC\uD569\uB2C8\uB2E4.`);
    }
    const newWord = {
      ...wordData,
      word: wordData.word.toLowerCase(),
      reviewCount: 0,
      difficulty: "none",
      // 초기 난이도 (학습 전)
      lastReviewed: null,
      addedDate: (/* @__PURE__ */ new Date()).toISOString(),
      bookId: wordData.bookId || this.settings.currentBookId
    };
    this.words.set(word, newWord);
    const book = this.books.get(newWord.bookId);
    if (book) {
      book.wordCount++;
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveBookToFile(book);
    }
    this.saveCallback();
  }
  // 단어 삭제
  async removeWord(word) {
    const wordKey = word.toLowerCase();
    const wordData = this.words.get(wordKey);
    if (!wordData) {
      throw new Error(`\uB2E8\uC5B4 "${word}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    const bookId = wordData.bookId;
    this.words.delete(wordKey);
    const book = this.books.get(bookId);
    if (book) {
      book.wordCount--;
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveBookToFile(book);
    }
    this.saveCallback();
  }
  // 단어 업데이트 (복습 결과)
  async updateWord(word, difficulty) {
    const wordKey = word.toLowerCase();
    const wordData = this.words.get(wordKey);
    if (!wordData) {
      throw new Error(`\uB2E8\uC5B4 "${word}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    wordData.reviewCount++;
    wordData.difficulty = difficulty;
    wordData.lastReviewed = (/* @__PURE__ */ new Date()).toISOString();
    this.statistics.totalReviews++;
    this.updateStreak();
    const book = this.books.get(wordData.bookId);
    if (book) {
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveBookToFile(book);
    }
    await this.saveSettings();
    this.saveCallback();
  }
  // 단어 업데이트 (복습 결과 + 스페이스드 리피티션 정보)
  async updateWordWithSchedule(word, difficulty, scheduleInfo) {
    const wordKey = word.toLowerCase();
    const wordData = this.words.get(wordKey);
    if (!wordData) {
      throw new Error(`\uB2E8\uC5B4 "${word}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    wordData.reviewCount++;
    wordData.difficulty = difficulty;
    wordData.lastReviewed = (/* @__PURE__ */ new Date()).toISOString();
    if (scheduleInfo) {
      wordData.scheduleInfo = scheduleInfo;
    }
    this.statistics.totalReviews++;
    this.updateStreak();
    const book = this.books.get(wordData.bookId);
    if (book) {
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveBookToFile(book);
    }
    await this.saveSettings();
    this.saveCallback();
  }
  // 단어 전체 데이터 업데이트 (LLM API로 가져온 정보로 덮어쓰기)
  async updateWordData(word, updatedWordData) {
    const wordKey = word.toLowerCase();
    const existingWord = this.words.get(wordKey);
    if (!existingWord) {
      throw new Error(`\uB2E8\uC5B4 "${word}"\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
    }
    const updatedWord = {
      ...updatedWordData,
      word: wordKey,
      reviewCount: existingWord.reviewCount,
      difficulty: existingWord.difficulty,
      lastReviewed: existingWord.lastReviewed,
      addedDate: existingWord.addedDate,
      bookId: existingWord.bookId
    };
    this.words.set(wordKey, updatedWord);
    const book = this.books.get(updatedWord.bookId);
    if (book) {
      book.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveBookToFile(book);
    }
    this.saveCallback();
  }
  // 단어 조회
  getWord(word) {
    return this.words.get(word.toLowerCase());
  }
  // 현재 book의 모든 단어 조회
  getAllWords() {
    return Array.from(this.words.values()).filter((word) => word.bookId === this.settings.currentBookId).sort((a, b) => {
      const wordA = typeof a.word === "string" ? a.word : "";
      const wordB = typeof b.word === "string" ? b.word : "";
      return wordA.localeCompare(wordB);
    });
  }
  // 특정 book의 모든 단어 조회
  getWordsByBook(bookId) {
    return Array.from(this.words.values()).filter((word) => word.bookId === bookId).sort((a, b) => {
      const wordA = typeof a.word === "string" ? a.word : "";
      const wordB = typeof b.word === "string" ? b.word : "";
      return wordA.localeCompare(wordB);
    });
  }
  // 복습 대상 단어 조회 (현재 book)
  getWordsForReview() {
    const now = /* @__PURE__ */ new Date();
    const reviewIntervalMs = this.settings.reviewInterval * 24 * 60 * 60 * 1e3;
    return Array.from(this.words.values()).filter((word) => word.bookId === this.settings.currentBookId).filter((word) => {
      if (!word.lastReviewed)
        return true;
      const lastReview = new Date(word.lastReviewed);
      const timeSinceLastReview = now.getTime() - lastReview.getTime();
      return timeSinceLastReview >= reviewIntervalMs;
    });
  }
  // 단어 검색 (현재 book)
  searchWords(query) {
    const lowerQuery = query.toLowerCase();
    return Array.from(this.words.values()).filter((word) => word.bookId === this.settings.currentBookId).filter(
      (word) => word.word.includes(lowerQuery) || word.meanings.some((meaning) => meaning.toLowerCase().includes(lowerQuery))
    );
  }
  // 통계 조회 (현재 book)
  getStatistics() {
    const words = Array.from(this.words.values()).filter((word) => word.bookId === this.settings.currentBookId);
    const totalWords = words.length;
    const totalReviews = this.statistics.totalReviews;
    const averageDifficulty = words.length > 0 ? words.reduce((sum, word) => {
      const difficultyValue = word.difficulty === "easy" ? 1 : word.difficulty === "good" ? 2 : 3;
      return sum + difficultyValue;
    }, 0) / words.length : 0;
    const wordsByDifficulty = {
      easy: words.filter((w) => w.difficulty === "easy").length,
      good: words.filter((w) => w.difficulty === "good").length,
      hard: words.filter((w) => w.difficulty === "hard").length
    };
    const recentActivity = this.calculateRecentActivity();
    return {
      totalWords,
      totalReviews,
      streakDays: this.statistics.streakDays,
      averageDifficulty,
      wordsByDifficulty,
      recentActivity
    };
  }
  // 일일 목표 진행률 조회 (현재 book)
  getDailyGoalProgress() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    const todayWords = Array.from(this.words.values()).filter((word) => word.bookId === this.settings.currentBookId).filter((word) => {
      if (!word.lastReviewed)
        return false;
      return new Date(word.lastReviewed).toDateString() === today;
    }).length;
    const goal = this.settings.dailyGoal;
    const percentage = goal > 0 ? Math.min(todayWords / goal * 100, 100) : 0;
    return {
      current: todayWords,
      goal,
      percentage
    };
  }
  // 설정 업데이트
  async updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
    await this.saveSettings();
    this.saveCallback();
  }
  // 데이터 저장용 형식으로 변환 (호환성 유지)
  getDataForSave() {
    return {
      books: Array.from(this.books.values()),
      words: Array.from(this.words.values()),
      settings: this.settings,
      statistics: this.statistics
    };
  }
  // 저장된 데이터에서 로드 (호환성 유지)
  async loadFromData(data) {
    await this.loadAllBooks();
  }
  // 연속 학습일 업데이트
  updateStreak() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    const lastStudyDate = this.statistics.lastStudyDate ? new Date(this.statistics.lastStudyDate).toDateString() : null;
    if (lastStudyDate === today) {
      return;
    }
    if (!lastStudyDate) {
      this.statistics.streakDays = 1;
    } else {
      const yesterday = /* @__PURE__ */ new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = yesterday.toDateString();
      if (lastStudyDate === yesterdayStr) {
        this.statistics.streakDays++;
      } else {
        this.statistics.streakDays = 1;
      }
    }
    this.statistics.lastStudyDate = (/* @__PURE__ */ new Date()).toISOString();
  }
  // 최근 7일 활동 계산
  calculateRecentActivity() {
    const activity = [];
    const today = /* @__PURE__ */ new Date();
    for (let i = 6; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = date.toDateString();
      const wordsStudied = Array.from(this.words.values()).filter((word) => {
        if (!word.lastReviewed)
          return false;
        return new Date(word.lastReviewed).toDateString() === dateStr;
      }).length;
      const reviewsCompleted = Array.from(this.words.values()).filter((word) => {
        if (!word.lastReviewed)
          return false;
        const reviewDate = new Date(word.lastReviewed);
        return reviewDate.toDateString() === dateStr;
      }).length;
      activity.push({
        date: date.toISOString().split("T")[0],
        wordsStudied,
        reviewsCompleted
      });
    }
    return activity;
  }
  // 단어장 폴더 경로 업데이트
  updateVocabularyFolderPath(newPath) {
    this.vocabularyFolderPath = newPath;
    this.initializeVocabularyFolder();
  }
};

// src/infrastructure/llm/LLMServiceAdapter.ts
var LLMServiceAdapter = class {
  constructor(settings) {
    this.llmService = new LLMService(settings);
  }
  async getWordData(request) {
    try {
      const wordInfo = await this.llmService.getWordInfo(request.word);
      return {
        success: true,
        data: {
          word: wordInfo.word,
          meaning: wordInfo.meanings,
          pronunciation: wordInfo.pronunciation,
          examples: wordInfo.examples,
          similarWords: wordInfo.similarWords
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  async testConnection() {
    return await this.llmService.testConnection();
  }
  updateSettings(settings) {
    this.llmService = new LLMService(settings);
  }
};

// src/infrastructure/external/WordServiceAdapter.ts
var WordServiceAdapter = class {
  constructor(settings) {
    this.wordService = new WordService(settings);
  }
  async getWordData(request) {
    try {
      const wordData = await this.wordService.getWordData(request.word);
      return {
        success: true,
        data: {
          word: wordData.word,
          meaning: wordData.meaning,
          pronunciation: wordData.pronunciation,
          examples: wordData.examples || [],
          similarWords: wordData.similarWords || []
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  updateSettings(settings) {
    this.wordService = new WordService(settings);
  }
};

// src/core/ports/services/ITTSServiceAdapter.ts
var TTSServiceAdapter = class {
  constructor(app, settings) {
    this.app = app;
    this.ttsService = TTSServiceFactory.createTTSService(app, settings);
  }
  async speakText(text) {
    await this.ttsService.speakText(text);
  }
  async speakWord(word) {
    await this.ttsService.speakWord(word);
  }
  async speakExample(example) {
    await this.ttsService.speakExample(example);
  }
  stopSpeaking() {
    this.ttsService.stopSpeaking();
  }
  updateSettings(settings) {
    this.ttsService.destroy();
    this.ttsService = TTSServiceFactory.createTTSService(this.app, settings);
  }
  isEnabled() {
    return true;
  }
  getAvailableVoices() {
    const voices = this.ttsService.getAvailableVoices();
    return [];
  }
  async testConnection() {
    return await this.ttsService.testConnection();
  }
  isPaused() {
    return this.ttsService.isPaused();
  }
  resume() {
    this.ttsService.resume();
  }
  pause() {
    this.ttsService.pause();
  }
  destroy() {
    this.ttsService.destroy();
  }
};

// src/shared/container/ServiceRegistry.ts
var ServiceRegistry = class {
  static registerServices(container2, app, settings) {
    container2.registerInstance("app", app);
    container2.registerInstance("settings", settings);
    container2.register("databaseManager", (app2) => {
      return new VocabularyDatabaseManager(
        app2,
        () => {
        },
        // saveCallback - DI에서는 빈 함수로 처리
        settings.vocabularyFolderPath
      );
    }, {
      dependencies: ["app"],
      singleton: true
    });
    container2.register("vocabularyRepository", VocabularyRepositoryAdapter, {
      dependencies: ["databaseManager"]
    });
    container2.register("bookRepository", BookRepositoryAdapter, {
      dependencies: ["databaseManager"]
    });
    container2.register("wordService", WordServiceAdapter, {
      dependencies: ["settings"]
    });
    container2.register("llmService", LLMServiceAdapter, {
      dependencies: ["settings"]
    });
    container2.register("ttsService", TTSServiceAdapter, {
      dependencies: ["app", "settings"]
    });
    container2.register("addWordUseCase", AddWordUseCase, {
      dependencies: ["vocabularyRepository", "bookRepository", "wordService"]
    });
    container2.register("createBookUseCase", CreateBookUseCase, {
      dependencies: ["bookRepository"]
    });
    container2.register("getWordsForReviewUseCase", GetWordsForReviewUseCase, {
      dependencies: ["vocabularyRepository", "bookRepository"]
    });
    container2.register("reviewWordUseCase", ReviewWordUseCase, {
      dependencies: ["vocabularyRepository"]
    });
  }
  static updateSettings(container2, settings) {
    container2.registerInstance("settings", settings);
    if (container2.has("ttsService")) {
      const ttsService = container2.resolve("ttsService");
      ttsService.updateSettings(settings);
    }
    if (container2.has("llmService")) {
      const llmService = container2.resolve("llmService");
      llmService.updateSettings(settings);
    }
    if (container2.has("wordService")) {
      const wordService = container2.resolve("wordService");
      wordService.updateSettings(settings);
    }
  }
};

// src/shared/ErrorBoundary.ts
var import_obsidian11 = require("obsidian");
var ErrorBoundary = class _ErrorBoundary {
  constructor() {
    this.errorHandlers = /* @__PURE__ */ new Map();
    this.isInitialized = false;
  }
  static getInstance() {
    if (!_ErrorBoundary.instance) {
      _ErrorBoundary.instance = new _ErrorBoundary();
    }
    return _ErrorBoundary.instance;
  }
  // 전역 에러 핸들러 초기화
  initialize() {
    if (this.isInitialized)
      return;
    window.addEventListener("error", (event) => {
      var _a;
      this.handleError({
        error: event.error || new Error(event.message),
        context: "Global Error",
        timestamp: Date.now(),
        stackTrace: (_a = event.error) == null ? void 0 : _a.stack
      });
    });
    window.addEventListener("unhandledrejection", (event) => {
      var _a;
      this.handleError({
        error: event.reason instanceof Error ? event.reason : new Error(String(event.reason)),
        context: "Unhandled Promise Rejection",
        timestamp: Date.now(),
        stackTrace: (_a = event.reason) == null ? void 0 : _a.stack
      });
    });
    this.isInitialized = true;
  }
  // 에러 핸들러 등록
  registerHandler(context, handler) {
    this.errorHandlers.set(context, handler);
  }
  // 에러 핸들러 제거
  unregisterHandler(context) {
    this.errorHandlers.delete(context);
  }
  // 에러 처리
  handleError(errorInfo) {
    console.error("Error caught by ErrorBoundary:", errorInfo);
    const userMessage = this.getUserFriendlyMessage(errorInfo.error);
    new import_obsidian11.Notice(userMessage, 0);
    this.errorHandlers.forEach((handler, context) => {
      try {
        handler(errorInfo);
      } catch (handlerError) {
        console.error(`Error in handler for context ${context}:`, handlerError);
      }
    });
  }
  // 안전한 함수 실행 래퍼
  async safeExecute(fn, context, fallback) {
    try {
      return await fn();
    } catch (error) {
      this.handleError({
        error: error instanceof Error ? error : new Error(String(error)),
        context,
        timestamp: Date.now(),
        stackTrace: error instanceof Error ? error.stack : void 0
      });
      return fallback;
    }
  }
  // 동기 함수용 안전한 실행
  safeExecuteSync(fn, context, fallback) {
    try {
      return fn();
    } catch (error) {
      this.handleError({
        error: error instanceof Error ? error : new Error(String(error)),
        context,
        timestamp: Date.now(),
        stackTrace: error instanceof Error ? error.stack : void 0
      });
      return fallback;
    }
  }
  // 사용자 친화적인 에러 메시지 생성
  getUserFriendlyMessage(error) {
    const errorType = error.name;
    const errorMessage = error.message;
    const friendlyMessages = {
      "NetworkError": "\uB124\uD2B8\uC6CC\uD06C \uC5F0\uACB0\uC5D0 \uBB38\uC81C\uAC00 \uC788\uC2B5\uB2C8\uB2E4. \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.",
      "TypeError": "\uB370\uC774\uD130 \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      "ReferenceError": "\uD544\uC694\uD55C \uB370\uC774\uD130\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
      "SyntaxError": "\uB370\uC774\uD130 \uD615\uC2DD\uC5D0 \uC624\uB958\uAC00 \uC788\uC2B5\uB2C8\uB2E4.",
      "QuotaExceededError": "\uC800\uC7A5 \uACF5\uAC04\uC774 \uBD80\uC871\uD569\uB2C8\uB2E4.",
      "SecurityError": "\uBCF4\uC548 \uC815\uCC45\uC73C\uB85C \uC778\uD574 \uC791\uC5C5\uC744 \uC218\uD589\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."
    };
    if (errorMessage.includes("API") || errorMessage.includes("fetch")) {
      return "API \uC11C\uBE44\uC2A4\uC5D0 \uC77C\uC2DC\uC801\uC778 \uBB38\uC81C\uAC00 \uC788\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.";
    }
    if (errorMessage.includes("file") || errorMessage.includes("File")) {
      return "\uD30C\uC77C \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uD30C\uC77C\uC774 \uC874\uC7AC\uD558\uB294\uC9C0 \uD655\uC778\uD574\uC8FC\uC138\uC694.";
    }
    if (errorMessage.includes("encrypt") || errorMessage.includes("decrypt")) {
      return "API \uD0A4 \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC744 \uB2E4\uC2DC \uD655\uC778\uD574\uC8FC\uC138\uC694.";
    }
    return friendlyMessages[errorType] || `\uC608\uC0C1\uCE58 \uBABB\uD55C \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4: ${errorMessage}`;
  }
  // 에러 복구 시도
  async attemptRecovery(error, context) {
    if (error.message.includes("fetch") || error.message.includes("network")) {
      try {
        await (0, import_obsidian11.requestUrl)({
          url: "https://www.google.com/favicon.ico",
          method: "HEAD"
        });
        return true;
      } catch (e) {
        return false;
      }
    }
    if (error.name === "QuotaExceededError") {
      try {
        localStorage.removeItem("temp-data");
        return true;
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  // 정리
  cleanup() {
    this.errorHandlers.clear();
    this.isInitialized = false;
  }
};

// src/main.ts
var EnglishVocabularyPlugin = class extends import_obsidian12.Plugin {
  async onload() {
    const errorBoundary = ErrorBoundary.getInstance();
    errorBoundary.initialize();
    errorBoundary.registerHandler("VocabularyPlugin", (errorInfo) => {
      var _a;
      if ((_a = errorInfo.context) == null ? void 0 : _a.includes("API")) {
        console.warn("API \uC5D0\uB7EC \uAC10\uC9C0, \uD3F4\uBC31 \uBAA8\uB4DC\uB85C \uC804\uD658");
      }
    });
    await this.loadSettings();
    this.container = container;
    ServiceRegistry.registerServices(this.container, this.app, this.settings);
    this.databaseManager = this.container.resolve("databaseManager");
    this.llmService = new LLMService(this.settings);
    this.ttsService = TTSServiceFactory.createTTSService(this.app, this.settings);
    try {
      await this.databaseManager.loadAllBooks();
    } catch (error) {
      console.error("\uB2E8\uC5B4\uC7A5 \uB370\uC774\uD130 \uB85C\uB4DC \uC2E4\uD328:", error);
      await this.migrateFromLegacyData();
    }
    this.addSettingTab(new VocabularySettingTab(this.app, this));
    this.addCommand({
      id: "open-vocabulary-modal",
      name: "\uC601\uC5B4 \uB2E8\uC5B4 \uD559\uC2B5 \uC2DC\uC791",
      callback: () => {
        new VocabularyModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "open-vocabulary-manager",
      name: "\uB2E8\uC5B4\uC7A5 \uBCF4\uAE30",
      callback: () => {
        new VocabularyManagerModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "add-words",
      name: "\uB2E8\uC5B4 \uCD94\uAC00",
      callback: () => {
        new AddWordsModal(this.app, this).open();
      }
    });
    this.addRibbonIcon("book", "\uB2E8\uC5B4\uC7A5 \uBCF4\uAE30", () => {
      new VocabularyManagerModal(this.app, this).open();
    });
  }
  onunload() {
    const errorBoundary = ErrorBoundary.getInstance();
    errorBoundary.unregisterHandler("VocabularyPlugin");
    errorBoundary.cleanup();
  }
  async loadSettings() {
    const data = await this.loadData();
    if (data && typeof data === "object" && "settings" in data) {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, data.settings);
    } else if (data && typeof data === "object" && "apiKey" in data) {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    } else {
      this.settings = Object.assign({}, DEFAULT_SETTINGS);
    }
    await this.migrateApiKeys();
  }
  // API 키 암호화 마이그레이션
  async migrateApiKeys() {
    let needsSave = false;
    if (this.settings.llmApiKey && this.isPlainTextApiKey(this.settings.llmApiKey)) {
      const plainKey = this.settings.llmApiKey;
      this.settings.llmApiKey = encryptApiKey(plainKey);
      needsSave = true;
    }
    if (this.settings.openaiApiKey && this.isPlainTextApiKey(this.settings.openaiApiKey)) {
      const plainKey = this.settings.openaiApiKey;
      this.settings.openaiApiKey = encryptApiKey(plainKey);
      needsSave = true;
    }
    if (this.settings.anthropicApiKey && this.isPlainTextApiKey(this.settings.anthropicApiKey)) {
      const plainKey = this.settings.anthropicApiKey;
      this.settings.anthropicApiKey = encryptApiKey(plainKey);
      needsSave = true;
    }
    if (this.settings.googleApiKey && this.isPlainTextApiKey(this.settings.googleApiKey)) {
      const plainKey = this.settings.googleApiKey;
      this.settings.googleApiKey = encryptApiKey(plainKey);
      needsSave = true;
    }
    if (needsSave) {
      await this.saveSettings();
    }
  }
  // API 키가 평문인지 확인하는 헬퍼 함수
  isPlainTextApiKey(apiKey) {
    if (!apiKey)
      return false;
    try {
      const decrypted = decryptApiKey(apiKey);
      return decrypted === apiKey;
    } catch (error) {
      return apiKey.startsWith("sk-") || apiKey.startsWith("sk-ant-") || apiKey.startsWith("AIza") || apiKey.length > 20;
    }
  }
  async saveSettings() {
    await this.saveAllData();
    if (this.llmService) {
      this.llmService = new LLMService(this.settings);
    }
    if (this.ttsService) {
      this.ttsService = TTSServiceFactory.createTTSService(this.app, this.settings);
    }
    if (this.container) {
      ServiceRegistry.updateSettings(this.container, this.settings);
    }
  }
  // 기존 data.json에서 MD 파일로 마이그레이션
  async migrateFromLegacyData() {
    try {
      const savedData = await this.loadData();
      if (savedData && savedData.database && Array.isArray(savedData.database.words)) {
        const legacyData = savedData.database;
        if (legacyData.words && legacyData.words.length > 0) {
          for (const word of legacyData.words) {
            try {
              await this.databaseManager.addWord({
                ...word,
                bookId: "default",
                pronunciation: word.pronunciation || ""
              });
            } catch (error) {
              console.warn(`\uB2E8\uC5B4 \uB9C8\uC774\uADF8\uB808\uC774\uC158 \uC2E4\uD328: ${word.word}`, error);
            }
          }
        }
        if (legacyData.settings) {
          await this.databaseManager.updateSettings(legacyData.settings);
        }
      }
    } catch (error) {
      console.error("\uB9C8\uC774\uADF8\uB808\uC774\uC158 \uC2E4\uD328:", error);
    }
  }
  // 모든 데이터 저장 (설정만 저장, 단어장 데이터는 MD 파일로 자동 저장됨)
  async saveAllData() {
    const data = {
      settings: this.settings
    };
    await this.saveData(data);
  }
};
